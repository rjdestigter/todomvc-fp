{"version":3,"sources":["serviceWorker.ts","modules/dom.ts","modules/store.ts","modules/fetch.ts","modules/emitter.ts","modules/document.ts","modules/todo.ts","index.ts"],"names":["Boolean","window","location","hostname","match","eventType","initial","input","init","tagName","options","rootEl","uri","subscribe","type","ret","el","S","fromSource","M","managed","chain","bracket","T","accessM","_","sync","su","queueUtils","next","ops","hasCB","unsubscribe","addEventListener","fromEvent","fn","a","_tag","emitter","documentLive","document","provideDocument","provide","getDocument","flow","pure","domLive","createElement","provideDom","ElementNotFound","selectors","name","Error","ParentElementNotFound","child","makeElementNotFound","makeParentElementNotFound","raiseError","element","toString","querySelector","O","$","pipe","map","fromOption","constant","parentElement","node","EmptyOptionOfElement","message","fetchLive","fetch","args","Promise","resolve","setTimeout","bind","provideFetch","FetchFailed","info","makeFetchFailed","url","error","todoDecoder","t","id","userId","title","completed","todosDecoder","eqTodoById","Eq","todo","storeT","todos","filterBy","new","Q","unboundedQueue","zip","ref","makeRef","queue","state","f","update","current","offer","get","head","subject","take","s","provideTodoStore","provideM","store","todoStore","access","fetchTodos","async","r","then","response","json","E","cb","decode","fromEither","_div","createDomNodeForTodo","innerHTML","todosUl","updateDomNodeOfTodo","todoLi","Do","return","label","checkbox","setAttribute","classList","add","remove","checked","value","identity","handleEvents","encaseEffect","target","todoIdEffect","div","parent","getAttribute","Number","todoId","tuple","clickedTodoId","hasAttribute","filter","li","addClass","removeClass","setFocus","focus","select","handleBlur","drain","handlTextInput","takeUntil","constVoid","fetchAndStoreTodos","logChanges","bindL","doL","subscription","log","emptyListOfTodos","getTodosDifference","A","optionOfPreviousTodoInDom","updateDomWithTodos","ul","acc","optionOfSiblingTodoInDom","domNodeOfPreviousTodoInList","chainTap","prepend","after","createAndUpdateTodoNode","commitStoreUpdatesToDom","scan","prev","sequence","effect","updateCounter","length","itemsLeft","makeHandleFilter","parSequenceT","links","forEach","link","handleClearCompleted","handleNewTodos","event","key","currentTarget","trim","Math","random","allTodosAreCompleted","constTrue","rest","handleMarkAllAsCompleted","susbscription","stateS","allCompleted","clickS","stateO","todosListed","listedTodo","merged","mergeAll","main","provided","Todo","Fetch","provideConsole","e","stopPropagation","removeEventListener","runToPromise","foo","console","catch","navigator","serviceWorker","ready","registration","unregister"],"mappings":"2NAYoBA,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2D,WCyKJC,ECxKuBC,ECgBHC,EAAoBC,EF8CxCC,EACAC,EGZAC,E,qIAlEWC,EAAM,eA6BNC,EAAY,SAA4BC,EAAkBC,GAA9C,OAA4D,SAGnFC,GAEA,OAAOC,IAAEC,WACPC,IAAEC,QAAQC,MACRF,IAAEG,QACAC,IAAEC,SAAQ,SAACC,GAAD,OACRF,IAAEG,MAAK,WAAO,IAAD,EACkBT,IAAEU,GAAGC,aAA1BC,EADG,EACHA,KAAMC,EADH,EACGA,IAAKC,EADR,EACQA,MAOnB,MAAO,CACLC,aAHShB,EAAKS,EAAEb,GAAKqB,iBAAiBjB,GAAMS,EAAEb,GAAKsB,WAGnCpB,EAAHqB,EAAS,SAAAC,GAEpB,OADAP,EAAK,CAAEQ,KAAM,QAASD,MACfrB,KAETe,MACAC,gBAIN,SAAAN,GAAC,OAAIA,EAAEO,gBAET,gBAAGF,EAAH,EAAGA,IAAKC,EAAR,EAAQA,MAAR,OAAoBd,IAAEU,GAAGW,QAAQR,EAAKC,SCtD/BQ,EAAY,eAJE,gBAKVC,UAGJC,EAAkBlB,IAAEmB,QAAQH,GAE5BI,EAAcpB,IAAEC,QAC3BoB,gBAAK,SAACnB,GAAD,OAAoBA,EAXA,mBAWgBF,IAAEsB,OJUhCC,EAAY,eAfN,WAgBV,CACLC,cAAe,SAACtC,EAAcC,GAAf,OACb8B,SAASO,cAActC,EAASC,MAIzBsC,EAAazB,IAAEmB,QAAQI,GAK9BG,E,kDACJ,WAAYC,GAAoB,IAAD,8BAC7B,0BAAWA,EAAX,kCACKC,KAAO,kBAFiB,E,sBADHC,QAOxBC,E,kDACJ,WAAYC,GAAgB,IAAD,8BACzB,wCAAyBA,EAAzB,iBACKH,KAAO,wBAFa,E,sBADOC,QAOvBG,EAAsB,SAACL,GAAD,OACjC,IAAID,EAAgBC,IAITM,GAFuBZ,eAAKW,EAAqBhC,IAAEkC,YAEvB,SAACC,GAAD,OACvC,IAAIL,EAAsBK,EAAQC,cA+DvBC,GA7D6BhB,eACxCY,EACAjC,IAAEkC,YA2DwC,SAACP,GAAD,OAAuB,SAGjElC,GAHiE,OAI9D6C,eAAe7C,EAAG4C,cAAcV,OAoCxBY,EAAO,SAACZ,GAAD,OAClBa,eACEpB,EACApB,IAAEyC,IAAIJ,EAAcV,IACpB3B,IAAEF,MAAME,IAAE0C,WAAWC,mBAASX,EAAoBL,QAQzCiB,EAAgB,SAC3BC,GAD2B,OAExBP,eAAeO,EAAKD,gBAEZE,EAAb,kDACE,WAAYC,GAAkB,IAAD,8BAC3B,cAAMA,IACDnB,KAAO,uBAFe,EAD/B,sBAA0CC,Q,GAWxC/C,EAgC6C,Q,OE/MlCkE,EAAgB,eARV,aASV,CACLC,MAAO,sCAAIC,EAAJ,yBAAIA,EAAJ,uBAAa,IAAIC,SAAQ,SAAAC,GAC9BC,YAAW,WACTD,EAAQ1E,OAAOuE,MAAMK,KAAK5E,QAAlB,aAA6BwE,MACpC,WAKIK,EAAevD,IAAEmB,QAAQ6B,GAEhCQ,E,kDACF,WAAYC,GAAe,IAAD,8BACxB,yCAA0BA,KACrB7B,KAAO,cAFY,E,sBADJC,QAOpB6B,EAAkB,SAACC,GAAD,OAAiB,SAACC,GAAD,OAAmB,IAAIJ,EAAJ,yB,SGqBtDK,EAAcC,IAClB,CACEC,GAAID,IACJE,OAAQF,IACRG,MAAOH,IACPI,UAAWJ,KAEb,QAYIK,EAAeL,IAAgBD,GAO/BO,EAAaC,aAAa,SAACC,GAAD,OAAgBA,EAAKP,KAAlCM,CAAsCA,YA2BnDE,GJtFmBxF,EIsFQ,CAC/ByF,MAAO,GACPC,SAAU,MACVC,IAAK,IJxFLlC,eACEmC,IAAEC,iBACF5E,IAAE6E,IAAIC,IAAIC,QAAQhG,EAAU,CAACA,GAAW,KACxCiB,IAAEF,OAAM,YAAqB,IAAD,mBAAlBkF,EAAkB,KAAXC,EAAW,KACpB3E,EAAO,SAAC4E,GAAD,OACX1C,eACEyC,EAAME,QAAO,gBAAEC,EAAF,0BAAe,CAACF,EAAEE,OAC/BpF,IAAEF,OAAM,gBAAEe,EAAF,2BAASmE,EAAMK,MAAMxE,QAG3ByE,EAAM9C,eAAKyC,EAAMK,IAAKtF,IAAEyC,IAAI8C,SAElC,OAAO/C,eACLgD,kBAAQ9F,IAAEC,WAAWC,IAAE0B,KAAKkB,eAAKwC,EAAMS,KAAMzF,IAAEyC,IAAIH,YACnDtC,IAAEyC,KAAI,SAACiD,GAAD,sBAAuBA,EAAvB,CAA0BJ,MAAKhF,kBI6EvCqF,EAAmB3F,IAAE4F,SACzBpD,eACE+B,EACAvE,IAAEyC,KAAI,SAACoD,GAAD,sBAjCE,kBAiCmBA,QAIzBC,EAAYtD,eAAKxC,IAAE+F,QAAO,SAAC7F,GAAD,OAAqBA,EArCzC,uBAwCN8F,GAAaxD,gBHtFGxD,EGMV,6CHLVgB,IAAEC,SAAQ,SAACC,GAAD,OACRF,IAAEiG,OAA6B,SAACC,GAC9B,IACEhG,EAnCW,cAmCJ+C,MAAMjE,EAAOC,GAAMkH,MAAK,SAAAC,GAAQ,OAAIA,EAASC,UAAQF,KAAK9E,eAAKiF,QAASJ,IAC/E,MAAOtC,GACPsC,EAAEI,OAAO5C,EAAiC,kBAAV1E,GAA6BA,EAAM2E,IAA1DD,CAA+DE,KAG1E,OAAO,SAAC2C,GACNA,EAAG7C,EAAiC,kBAAV1E,GAA6BA,EAAM2E,IAA1DD,CAA+D,aGgFxE1D,IAAEF,OAAM,SAACsG,GAAD,OAAcpG,IAAEG,MAAK,kBAAMgE,EAAaqC,OAAOJ,SAEvDpG,IAAEF,MAAME,IAAEyG,aAsBNC,ILpEJxH,EKoEyB,MLlEtBc,IAAEC,SAAQ,SAACC,GAAD,OAAYF,IAAEsB,KAAKpB,EAzEf,YAyEsBsB,cAActC,EAASC,QK6E1DwH,GAAuBnE,eAC3BkE,GACA1G,IAAEF,OAAM,SAACL,GAAD,OACNO,IAAEG,MAAK,WAEL,OADAV,EAAGmH,UAzBC,oOA0BGvE,EAAc,KAAdA,CAAoB5C,SAG/BO,IAAEF,MACAE,IAAE0C,WACAC,mBACEX,EAAoB,mDAetB6E,GAAUtE,EAAoB,cAW9BuE,GAAsB,SAACxC,GAAD,OAAgB,SAACyC,GAAD,OAC1CvE,eACEwE,aAAG1E,UAEAgB,KAAK,QAASjB,EAAc,QAAdA,CAAuB0E,IACrCzD,KAAK,WAAYjB,EAAc,QAAdA,CAAuB0E,IACxCzD,KAAK,QAASjB,EAAgC,aAAhCA,CAA8C0E,IAC5DE,QAAO,gBAAGC,EAAH,EAAGA,MAAOC,EAAV,EAAUA,SAAUnI,EAApB,EAAoBA,MAApB,OACNgB,IAAEG,MAAK,WAcL,OAZA+G,EAAMN,UAAYtC,EAAKL,MAGvB8C,EAAOK,aAAa,eAAgB,GAAK9C,EAAKP,IAG9CO,EAAKJ,UACD6C,EAAOM,UAAUC,IAAI,aACrBP,EAAOM,UAAUE,OAAO,aAC5BJ,EAASK,QAAUlD,EAAKJ,UACxBlF,EAAMyI,MAAQnD,EAAKL,MAEZ8C,QAIb/G,IAAE0C,WAAWC,mBAASd,MAAM,MAC5B7B,IAAEF,MAAM4H,eAiCNC,GAAenF,eAEnBqE,GACAnH,IAAEkI,aAEFlI,IAAEI,MAAM0C,eAAKlD,EAAU,WAEvBI,IAAE+C,KAAI,SAACvC,GAAD,OAAOA,EAAE2H,UACfnI,IAAE+C,IAAIH,gBACN5C,IAAEI,MAAMJ,IAAEgD,YACVhD,IAAEI,OAAM,SAACI,GACP,IAAM2H,EAAS3H,EAET4H,EA3CY,SAACD,GAAD,OACpBrF,eACEI,EAA2CiF,GAC3CvF,SAAQ,SAACyF,GAAD,OAASnF,EAA6CmF,MAC9D/H,IAAEsB,KACFtB,IAAEF,MAAME,IAAE0C,WAAWC,mBAASV,EAA0B4F,MACxD7H,IAAEyC,KAAI,SAACuF,GAAD,OACJxF,eACEwF,EAAOC,aAAa,gBACpB3F,eACAA,MAAM4F,QACN5F,OAAM,SAAC6F,GAAD,OAAYC,gBAAMD,EAAQH,UAGpChI,IAAEF,MAAME,IAAE0C,WAAWC,mBAASV,EAA0B4F,OA6BnCQ,CAAcR,GAGnC,OAAIA,EAAOS,aAAa,eACf9F,eACLsF,EACA9H,IAAE6E,IAAIiB,GACN9F,IAAEF,OAAM,mCAAGqI,EAAH,mCACA7H,MAAK,SAAC2E,GACV,OAAO,eACFA,EADL,CAEET,MAAOS,EAAMT,MAAM+D,QAAO,SAACjE,GAAD,OAAUA,EAAKP,KAAOoE,aAItDzI,IAAEkI,cAIKC,EAAOS,aAAa,eACtB9F,eACLsF,EACA9H,IAAE6E,IAAIiB,GACN9F,IAAEF,OAAM,mCAAGqI,EAAH,mCACA7H,MAAK,SAAC2E,GACV,OAAO,eACFA,EADL,CAEET,MAAOS,EAAMT,MAAM/B,KAAI,SAAC6B,GAAD,OACrBA,EAAKP,KAAOoE,EAAZ,eACS7D,EADT,CACeJ,WAAYI,EAAKJ,YAC5BI,aAKZ5E,IAAEkI,cAIKC,EAAOS,aAAa,aACtB9F,eACLsF,EACA9H,IAAEF,OAAM,YAAmB,IAAD,mBAAhBqI,EAAgB,KAARK,EAAQ,KAElBC,EAAWzI,IAAEG,MAAK,WACtBqI,EAAGnB,UAAUC,IAAI,cAIboB,EAAc1I,IAAEG,MAAK,WACzBqI,EAAGnB,UAAUE,OAAO,cAGhBvI,EAAQwD,eACZgG,EACAnG,EAAgC,cAChCrC,IAAE0C,WAAWC,mBAASX,EAAoB,cAC1ChC,IAAEF,OAAM,SAACd,GAEP,IAAM2J,EAAW3I,IAAEG,MAAK,WACtBnB,EAAM4J,QACN5J,EAAM6J,YAKFC,EAAatG,eACjBxD,EACAM,EAAU,QACVI,IAAE+F,KAAK,GACP/F,IAAEqJ,MACF/I,IAAE6E,IAAI6D,IAIFM,EAAiBxG,eACrBxD,EAEAM,EAAU,SACVI,IAAEI,MACA6C,mBACEH,eACEsD,EAEA9F,IAAEF,OAAM,SAAC+F,GAAD,OACNA,EAAMvF,MAAK,SAAC2E,GAAD,sBACNA,EADM,CAETT,MAAOS,EAAMT,MAAM/B,KAAI,SAAC6B,GAAD,OACrBA,EAAKP,KAAOoE,EAAZ,eACS7D,EADT,CACeL,MAAOjF,EAAMyI,QACxBnD,aAIV5E,IAAEkI,gBAKRlI,IAAEuJ,UAAUH,GACZpJ,IAAEqJ,OAGJ,OAAOvG,eAAKmG,EAAU3I,IAAE6E,IAAImE,QAIhC,OAAOxG,eAAKiG,EAAUzI,IAAE6E,IAAI7F,OAE9BU,IAAEkI,cAIClI,IAAEkI,aAAa5H,IAAEsB,KAAK4H,2BAE/BxJ,IAAEqJ,OAyBEI,GAAqB3G,eAAKwD,GAAYhG,IAAEF,OAflB,SAAC0E,GAAD,OAC1BhC,eACEsD,EACA9F,IAAEF,OAAM,SAAC+F,GAAD,OAAWA,EAAMvF,MAAK,SAAC2E,GAAD,sBAAiBA,EAAjB,CAAwBT,qBAcpD4E,GAAapJ,IAAEgH,KAClB1D,KAAK,QAASwC,GACduD,MAAM,gBAAgB,qBAAGxD,MAAkBvG,aAC3CgK,KAAI,gBAAGC,EAAH,EAAGA,aAAH,OACH/G,eAAK+G,EAAc7J,IAAEI,MAAMuB,eAAKmI,IAAK9J,IAAEkI,eAAgBlI,IAAEqJ,UAE1D9B,OAAOiC,aAUJO,GAA0B,GAa1BC,GAAqBC,aAAavF,GAqClCwF,GAKF5J,IAAEsB,KAAKgB,QAgDLuH,GAAqB,SAACC,GAAD,OAA0B,SAACtF,GAAD,OACnDhC,eACEgC,EAEAmF,SAASC,IAA2B,SAACG,EAAKzF,GAAN,OAClC9B,eAEEuH,EACA/J,IAAEF,OAAM,SAACkK,GAAD,OACNxH,eACEsH,EACAzH,EAAa,yBAAkCiC,EAAKP,GAAvC,OACbzB,OAIEK,mBAnDkB,SAACmH,GAAD,OAA0B,SACxDG,GADwD,OAErD,SAAC3F,GAAD,OACH9B,eAEEmE,GAEA3G,IAAEF,MAAMgH,GAAoBxC,IAG5BtE,IAAEkK,UAAS,SAAC1B,GAAD,OACThG,eACEyH,EACA3H,OAEEK,mBAAS3C,IAAEG,MAAK,kBAAM2J,EAAGK,QAAQ3B,QAEjC,SAACyB,GAAD,OACEjK,IAAEG,MAAK,kBAAM8J,EAA4BG,MAAM5B,gBAkC3C6B,CAAwBP,EAAxBO,CAA4BL,EAA5BK,CAAsD/F,IAGxDwC,GAAoBxC,IAEtBtE,IAAEyC,IAAIH,mBAiBZgI,GAA0BtK,IAAEgH,KAC/B1D,KAAK,QAASwC,GACduD,MAAM,gBAAgB,qBAAGxD,MAAkBvG,aAC3CgE,KAAK,KAAMuD,IAEXyC,KAAI,gBAAGC,EAAH,EAAGA,aAAcO,EAAjB,EAAiBA,GAAjB,OACHtH,eACE+G,EACA7J,IAAE+C,KAAI,SAACwC,GAAD,MACe,QAAnBA,EAAMR,SACFQ,EAAMT,MACNhC,eACEyC,EAAMT,MACNmF,UAAS,SAACrF,GAAD,MACY,cAAnBW,EAAMR,SACFH,EAAKJ,WACJI,EAAKJ,iBAKpBxE,IAAE+C,IAAIkH,WAAW,KAEjBjK,IAAE6K,KAAKnC,gBAAMqB,GAAkBA,KAAmB,WAASnJ,GAAT,IAAEkK,EAAF,2BAChDpC,gBAAM9H,EAAMkK,MAEd9K,IAAEI,OAAM,gBA/Ic0E,EA+Id,mBAAElE,EAAF,KAAQkK,EAAR,YACN9K,IAAEkI,aACApF,gBAjJkBgC,EAmJGkF,GAAmBc,EAAMlK,GAlJtDkC,eACEgC,EACAmF,OAAM,SAACrF,GAAD,OACJ9B,eAEED,EAAC,yBAAkC+B,EAAKP,GAAvC,OAED/D,IAAEF,OAAM,SAAC0I,GAAD,OAAQxI,IAAEG,KAAKqI,EAAGjB,OAAOjE,KAAKkF,WAG1CmB,gBAAgBc,SAASzK,IAAE0K,UA2InB1K,IAAE6E,IAAIgF,GAAmBC,EAAnBD,CAAuBvJ,SAInCZ,IAAEqJ,UAGL9B,OAAOiC,aAEJyB,GAAgBnI,eACpBsD,EACA9F,IAAEF,OAAM,SAAC+F,GAAD,OAAWA,EAAMvG,aACzBI,IAAEkI,aACFlI,IAAEI,MAAM4H,YACRhI,IAAE+C,KAAI,SAACwC,GAAD,OAAWA,EAAMT,SACvB9E,IAAE+C,KAAI,SAAC+B,GAAD,OACJhC,eACEgC,EACAmF,UAAS,SAACrF,GAAD,OAAWA,EAAKJ,iBAG7BxE,IAAE+C,KAAI,SAAC+B,GAAD,OAAWA,EAAMoG,UACvBlL,IAAEI,OAAM,SAAC+K,GAAD,OACNnL,IAAEkI,aACApF,eACED,EAAE,eACFvC,IAAEyC,IAAIJ,EAAc,WACpBrC,IAAEF,MACAE,IAAE0C,WAAWC,mBAASX,EAAoB,2BAE5ChC,IAAEF,OAAM,SAACL,GAAD,OACNO,IAAEG,MAAK,WACLV,EAAGmH,UAAY,GAAKiE,aAM9BnL,IAAEqJ,OAGE+B,GAAmB,SAACrG,GAAD,OACvBjC,eACED,EAAC,sBAAmCkC,IACpC/E,IAAEkI,aACFlI,IAAEI,MAAMR,EAAU,UAClBI,IAAEI,MACA6C,mBACEjD,IAAEkI,aACApF,eACExC,IAAE+K,aACAxI,EAAC,mBACDA,EAAC,sBACDA,EAAC,0BAEHvC,IAAEF,OAAM,SAACkL,GAAD,OACNhL,IAAEG,MAAK,WACL6K,EAAMC,SAAQ,SAACC,GAAD,OAAUA,EAAK7D,UAAUE,OAAO,yBAO1D7H,IAAEI,MACA6C,mBACEjD,IAAEkI,aACApF,eACEsD,EACA9F,IAAEF,OAAM,SAAC+F,GAAD,OAAWA,EAAMvF,MAAK,SAAC2E,GAAD,sBAAiBA,EAAjB,CAAwBR,uBAK9D/E,IAAEI,MACA6C,mBACEjD,IAAEkI,aACApF,eACED,EAAC,sBAAmCkC,IACpCzE,IAAEF,OAAM,SAACoL,GAAD,OACNlL,IAAEG,MAAK,WACL+K,EAAK7D,UAAUC,IAAI,sBAO/B5H,IAAEqJ,QAGAoC,GAAuB3I,eAC3BD,EAAC,oBACD7C,IAAEkI,aACFlI,IAAEI,MAAMR,EAAU,UAClBI,IAAEI,MACA6C,mBACEjD,IAAEkI,aACApF,eACEsD,EACA9F,IAAEF,OAAM,SAAC+F,GAAD,OACNA,EAAMvF,MAAK,SAAC2E,GAAD,sBACNA,EADM,CAETT,MAAOhC,eACLyC,EAAMT,MACNmF,UAAS,SAACrF,GAAD,OAAWA,EAAKJ,0BAQvCxE,IAAEqJ,OAGEqC,GAAiB5I,eACrBD,EAAoB,aACpB7C,IAAEkI,aACFlI,IAAEI,MAAMR,EAAU,UAClBI,IAAE6I,QAAO,SAAC8C,GAAD,MAAyB,UAAdA,EAAMC,OAC1B5L,IAAE+C,KAAI,SAAC4I,GAAD,OAAWA,EAAME,iBACvB7L,IAAE+C,IAAIH,gBACN5C,IAAEI,MAAMJ,IAAEgD,YACVhD,IAAE6I,QAAO,SAACvJ,GAAD,QAAaA,EAAMyI,MAAM+D,UAClC9L,IAAEI,OAAM,SAACd,GAAD,OACNU,IAAEkI,aACApF,eACEsD,EACA9F,IAAEF,OAAM,SAAC+F,GAAD,OACNA,EAAMvF,MAAK,SAAC2E,GAAD,sBACNA,EADM,CAETT,MAAM,CACJ,CACET,GAAI0H,KAAKC,SACTzH,MAAOjF,EAAMyI,MACbvD,WAAW,EACXF,OAAQyH,KAAKC,WALZ,mBAOAzG,EAAMT,gBAIfxE,IAAEF,MACA6C,mBACE3C,IAAEG,MAAK,WACLnB,EAAMyI,MAAQ,aAO1B/H,IAAEqJ,OAGE4C,GAAuB,SAAvBA,EAAwBnH,GAAD,OAC3BhC,eACEgC,EACAmF,WACEiC,aACA,SAACtH,EAAMuH,GAAP,OAAgBvH,EAAKJ,WAAayH,EAAqBE,QAIvDC,GAA2BtJ,eAC/BD,EAAoB,eACpBvC,IAAE6E,IAAIiB,GACN9F,IAAEF,OAAM,mCAAEd,EAAF,KAAS6G,EAAT,YACNrD,eACEqD,EAAMvG,UACNU,IAAEyC,KAAI,SAACsJ,GAAD,OAAmB3D,gBAAMpJ,EAAO6G,EAAOkG,UAGjDrM,IAAEkI,aACFlI,IAAEI,OACA,YAAoC,IAAD,mBAAjCd,EAAiC,KAA1B6G,EAA0B,KAAnBkG,EAAmB,KAC3BC,EAAkCxJ,eACtCuJ,EACArM,IAAE+C,KAAI,SAACwC,GAAD,MACe,QAAnBA,EAAMR,SACFQ,EAAMT,MACNhC,eACEyC,EAAMT,MACNmF,UAAS,SAACrF,GAAD,MACY,cAAnBW,EAAMR,SACFH,EAAKJ,WACJI,EAAKJ,iBAKpBxE,IAAE+C,IAAIkH,WAAW,KACjBjK,IAAE+C,KAAI,SAAC+B,GAAD,OAAW4D,gBAAMuD,GAAqBnH,GAAQA,MACpD9E,IAAEI,OAAM,mCAAEmM,EAAF,iBACNvM,IAAEkI,aACA5H,IAAEG,MAAK,WACLnB,EAAMwI,QAAUyE,SAItBvM,IAAE+C,IAAIyG,cAGFgD,EAAS1J,eACblD,EAAU,QAAVA,CAAmBN,GACnBU,IAAEI,MACA6C,mBACEjD,IAAEkI,aACApF,eACEqD,EAAMP,IACNtF,IAAEF,OAAM,SAACqM,GAAD,OACN3J,eACE2J,EACA7J,OAAM,SAAC2C,GACL,IAAMmH,EAAc5J,eACC,QAAnByC,EAAMR,SACFQ,EAAMT,MACNhC,eACEyC,EAAMT,MACNmF,UAAS,SAACrF,GAAD,MACY,cAAnBW,EAAMR,SACFH,EAAKJ,WACJI,EAAKJ,cAGlByF,WAAW,KAGPzF,GAAayH,GAAqBS,GAExC,OAAOvG,EAAMvF,MAAK,SAAC2E,GAAD,sBACbA,EADa,CAEhBT,MAAOS,EAAMT,MAAM/B,KAAI,SAAC6B,GAAD,OACrB9B,eACE4J,EACAzC,gBAAe,SAAC0C,GAAD,OACbA,EAAWtI,KAAOO,EAAKP,GACnBzB,OACAA,OAAA,eAAYgC,EAAZ,CAAkBJ,kBAExB5B,OAAOK,mBAAS2B,GAAOoD,wBAK/BpF,YAA2BK,mBAAS3C,IAAEG,KAAK+I,uBAOvDxJ,IAAE+C,IAAIyG,cAGFoD,EAAS5M,IAAE6M,SAAS,CAACP,EAAQE,IAEnC,OAAO1J,eAAK8J,MAuDhB5M,IAAEqJ,OAWSyD,GAAOhK,eAClBxC,IAAE+K,aACA3B,GACAD,GACAxB,GACA2C,GACAK,GACAG,GAAiB,OACjBA,GAAiB,UACjBA,GAAiB,aACjBM,GACAD,GACAW,IAEFnG,GC75BI8G,GAAWjK,eAEfkK,GAEAjL,EAEAP,EAEAyL,EAEAC,IAEA5M,IAAEmB,SH0CF/B,EG1C0B6B,SH4CnB,eACJ5B,EAAM,CACLsB,UAAW,SAA4BpB,GAA5B,OAAiD,SAC1DgH,GAQA,OAFAnH,EAAOsB,iBAAiBnB,GAJN,SAACsN,GAEjB,OADAA,EAAEC,kBACKvG,EAAGsG,MAIL7M,IAAEG,MAAK,kBAAMf,EAAO2N,oBAAoBxN,EAAMgH,QAEvD7F,iBAAkB,SAA6EjB,GAA7E,OAA8F,SAG9GF,GAH8G,OAI3G,SAACgH,GAOJ,OAFA9G,EAAGiB,iBAAiBnB,GAJF,SAACsN,GAEjB,OADAA,EAAEC,kBACKvG,EAAGsG,MAIL7M,IAAEG,MAAK,kBAAMV,EAAGsN,oBAAoBxN,EAAMgH,cG7DzDvG,IAAEgN,aAAaP,IACZtG,MAAK,SAAC8G,GAAD,OAASC,QAAQ1D,IAAI,OAAQyD,MAClCE,OAAM,SAACvJ,GACNsJ,QAAQtJ,MAAMA,MPqGZ,kBAAmBwJ,WACrBA,UAAUC,cAAcC,MACrBnH,MAAK,SAAAoH,GACJA,EAAaC,gBAEdL,OAAM,SAAAvJ,GACLsJ,QAAQtJ,MAAMA,EAAMb,c","file":"static/js/main.10d16137.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL || '',\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import { effect as T, stream as S } from \"@matechs/effect\";\r\nimport * as O from \"fp-ts/lib/Option\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { constant, flow, identity } from \"fp-ts/lib/function\";\r\nimport { subscribe, Emitter, EventFor } from \"./emitter\";\r\nimport { DocumentEnv, getDocument } from \"./document\";\r\n\r\n/**\r\n * Environment\r\n */\r\nexport const uri = \"@uri/dom\";\r\n\r\nexport interface Dom {\r\n  [uri]: {\r\n    createElement<K extends keyof HTMLElementTagNameMap>(\r\n      tagName: K,\r\n      options?: ElementCreationOptions\r\n    ): HTMLElementTagNameMap[K];\r\n    createElement(\r\n      tagName: string,\r\n      options?: ElementCreationOptions\r\n    ): HTMLElement;\r\n  };\r\n}\r\n\r\nexport const domLive: Dom = {\r\n  [uri]: {\r\n    createElement: (tagName: any, options?: ElementCreationOptions) =>\r\n      document.createElement(tagName, options),\r\n  },\r\n};\r\n\r\nexport const provideDom = T.provide(domLive);\r\n\r\n/**\r\n * Errors\r\n */\r\nclass ElementNotFound extends Error {\r\n  constructor(selectors: string) {\r\n    super(`$(${selectors}) did not return an element.`);\r\n    this.name = \"ElementNotFound\";\r\n  }\r\n}\r\n\r\nclass ParentElementNotFound extends Error {\r\n  constructor(child: string) {\r\n    super(`Parent of node: ${child} not found.`);\r\n    this.name = \"ParentElementNotFound\";\r\n  }\r\n}\r\n\r\nexport const makeElementNotFound = (selectors: string) =>\r\n  new ElementNotFound(selectors);\r\n\r\nexport const raiseElementNotFound = flow(makeElementNotFound, T.raiseError);\r\n\r\nexport const makeParentElementNotFound = (element: HTMLElement) =>\r\n  new ParentElementNotFound(element.toString());\r\n\r\nexport const raiseParentElementNotFound = flow(\r\n  makeParentElementNotFound,\r\n  T.raiseError\r\n);\r\n\r\n/**\r\n * Utilities\r\n */\r\ninterface CreateElement {\r\n  <K extends keyof HTMLElementTagNameMap>(\r\n    tagName: K,\r\n    options?: ElementCreationOptions\r\n  ): T.Effect<unknown, Dom, never, HTMLElementTagNameMap[K]>;\r\n  (tagName: string, options?: ElementCreationOptions): T.Effect<\r\n    unknown,\r\n    Dom,\r\n    never,\r\n    HTMLElement\r\n  >;\r\n}\r\n\r\nexport const createElement: CreateElement = (\r\n  tagName: string,\r\n  options?: ElementCreationOptions\r\n) => T.accessM((_: Dom) => T.pure(_[uri].createElement(tagName, options)));\r\n\r\n/**\r\n * QuerySelector\r\n */\r\ninterface QuerySelector {\r\n  <K extends keyof HTMLElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: TNode\r\n  ) => O.Option<HTMLElementTagNameMap[K]>;\r\n  <K extends keyof SVGElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: TNode\r\n  ) => O.Option<SVGElementTagNameMap[K]>;\r\n  <E extends Element = Element>(selectors: string): <TNode extends ParentNode>(\r\n    node: TNode\r\n  ) => O.Option<E>;\r\n}\r\n\r\ninterface QuerySelectorT {\r\n  <K extends keyof HTMLElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: O.Option<TNode>\r\n  ) => O.Option<HTMLElementTagNameMap[K]>;\r\n  <K extends keyof SVGElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: O.Option<TNode>\r\n  ) => O.Option<SVGElementTagNameMap[K]>;\r\n  <E extends Element = Element>(selectors: string): <TNode extends ParentNode>(\r\n    node: O.Option<TNode>\r\n  ) => O.Option<E>;\r\n}\r\n\r\nexport const querySelector: QuerySelector = (selectors: string) => <\r\n  TNode extends ParentNode\r\n>(\r\n  el: TNode\r\n) => O.fromNullable(el.querySelector(selectors));\r\n\r\nexport const querySelectorO: QuerySelectorT = (selectors: string) => <\r\n  TNode extends ParentNode\r\n>(\r\n  nodeOT: O.Option<TNode>\r\n) =>\r\n  pipe(\r\n    nodeOT,\r\n    O.map((el) => querySelector(selectors)(el))\r\n  );\r\n\r\n/**\r\n * $\r\n */\r\ninterface $ {\r\n  <K extends keyof HTMLElementTagNameMap>(selectors: K): T.Effect<\r\n    unknown,\r\n    DocumentEnv,\r\n    ElementNotFound,\r\n    HTMLElementTagNameMap[K]\r\n  >;\r\n  <K extends keyof SVGElementTagNameMap>(selectors: K): T.Effect<\r\n    unknown,\r\n    DocumentEnv,\r\n    ElementNotFound,\r\n    SVGElementTagNameMap[K]\r\n  >;\r\n  <E extends Element = Element>(selectors: string): T.Effect<\r\n    unknown,\r\n    DocumentEnv,\r\n    ElementNotFound,\r\n    E\r\n  >;\r\n}\r\n\r\nexport const $: $ = (selectors: string) =>\r\n  pipe(\r\n    getDocument,\r\n    T.map(querySelector(selectors)),\r\n    T.chain(T.fromOption(constant(makeElementNotFound(selectors))))\r\n  );\r\n\r\n/**\r\n * ```hs\r\n * parentElement :: Node -> Option<HTMLelement>\r\n * ```\r\n */\r\nexport const parentElement = <TNode extends Node, TParentNode extends Node>(\r\n  node: TNode\r\n) => O.fromNullable(node.parentElement as TParentNode | null);\r\n\r\nexport class EmptyOptionOfElement extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = \"EmptyOptionOfElement\";\r\n  }\r\n}\r\n\r\nexport const raiseEmptyOptionOfElement = (message: string) =>\r\n  T.raiseError(new EmptyOptionOfElement(message));\r\n\r\nexport const makeEventStream = <TEventType extends string>(\r\n  eventType: TEventType\r\n) => <\r\n  R,\r\n  E,\r\n  A extends Pick<Element, \"addEventListener\" | \"removeEventListener\">\r\n>(\r\n  elementT: T.Effect<unknown, R, E, O.Option<A>>\r\n) =>\r\n  pipe(\r\n    elementT,\r\n    T.map((elementO) =>\r\n      pipe(\r\n        elementO,\r\n        O.map(subscribe(eventType)),\r\n        (effect) => effect,\r\n        O.fold<\r\n          S.Stream<unknown, Emitter, never, EventFor<TEventType>>,\r\n          S.Stream<unknown, Emitter, EmptyOptionOfElement, EventFor<TEventType>>\r\n        >(\r\n          constant(\r\n            S.raised(\r\n              new EmptyOptionOfElement(\r\n                `Option does not contain some element to create ${eventType} event stream for`\r\n              )\r\n            )\r\n          ),\r\n          identity\r\n        )\r\n      )\r\n    )\r\n  );\r\n\r\nexport const makeClickStream = makeEventStream(\"click\");\r\n","import {\r\n  effect as T,\r\n  ref,\r\n  stream as S,\r\n  queue as Q,\r\n  managed as M,\r\n} from \"@matechs/effect\";\r\nimport { subject } from \"@matechs/effect/lib/stream\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport * as O from \"fp-ts/lib/Option\";\r\nimport { head } from \"fp-ts/lib/ReadonlyArray\";\r\n\r\nexport interface Store<A> {\r\n  next: (f: (current: A) => A) => T.Async<void>;\r\n  get: T.Sync<O.Option<A>>;\r\n  interrupt: T.Effect<unknown, unknown, never, void>;\r\n  subscribe: T.Sync<S.Stream<unknown, unknown, never, A>>;\r\n}\r\n\r\nexport const store = <A>(initial?: A) =>\r\n  pipe(\r\n    Q.unboundedQueue<A>(),\r\n    T.zip(ref.makeRef(initial ? [initial] : [])),\r\n    T.chain(([queue, state]) => {\r\n      const next = (f: (current: A) => A) =>\r\n        pipe(\r\n          state.update(([current]) => [f(current)]),\r\n          T.chain(([a]) => queue.offer(a))\r\n        );\r\n\r\n      const get = pipe(state.get, T.map(head));\r\n\r\n      return pipe(\r\n        subject(S.fromSource(M.pure(pipe(queue.take, T.map(O.some))))),\r\n        T.map((s): Store<A> => ({ ...s, get, next }))\r\n      );\r\n    })\r\n  );\r\n","import { effect as T } from \"@matechs/effect\";\r\nimport * as E from \"fp-ts/lib/Either\";\r\nimport { flow } from \"fp-ts/lib/function\";\r\n\r\nexport const uri = \"@uri/fetch\";\r\n\r\nexport interface Fetch {\r\n  [uri]: {\r\n    fetch: typeof window.fetch;\r\n  }\r\n}\r\n\r\nexport const fetchLive: Fetch = {\r\n  [uri]: {\r\n    fetch: (...args) => new Promise(resolve => {\r\n      setTimeout(() => {\r\n        resolve(window.fetch.bind(window)(...args))\r\n      }, 2000)\r\n    })\r\n  },\r\n};\r\n\r\nexport const provideFetch = T.provide(fetchLive)\r\n\r\nclass FetchFailed extends Error {\r\n    constructor(info: string) {\r\n      super(`Unable to fetch: ${info}`);\r\n      this.name = \"FetchFailed\";\r\n    }\r\n  }\r\n\r\nconst makeFetchFailed = (url: string) => (error: string) => new FetchFailed(\r\n    `Fetching data from `\r\n)\r\n\r\nexport const fetch = (input: RequestInfo, init?: RequestInit) =>\r\n  T.accessM((_: Fetch) =>\r\n    T.async<FetchFailed, Response>((r) => {\r\n      try {\r\n        _[uri].fetch(input, init).then(response => response.json()).then(flow(E.right, r));\r\n      } catch (error) {\r\n        r(E.left(makeFetchFailed(typeof input === 'string' ? input : input.url)(error)));\r\n      }\r\n\r\n      return (cb) => {\r\n        cb(makeFetchFailed(typeof input === 'string' ? input : input.url)(\"\"));\r\n      };\r\n    })\r\n  );\r\n","import { effect as T, stream as S, managed as M } from \"@matechs/effect\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { log } from \"@matechs/console\";\r\n\r\nexport const uri = \"@uri/emitter\";\r\n\r\nexport type EventFor<TEventType extends string> = TEventType extends\r\n  | \"keypress\"\r\n  | \"keyup\"\r\n  | \"keydown\"\r\n  ? KeyboardEvent\r\n  : TEventType extends \"click\" | \"dblclick\" | \"mousemove\" | \"mousedown\" | \"mouseup\"\r\n  ? MouseEvent\r\n  : Event;\r\n\r\nexport type EventHandler<TEventType extends string> = (\r\n  evt: EventFor<TEventType>\r\n) => void;\r\n\r\nexport interface Emitter {\r\n  [uri]: {\r\n    fromEvent: <TEventType extends string>(\r\n      type: TEventType\r\n    ) => (cb: EventHandler<TEventType>) => T.Effect<unknown, unknown, never, void>;\r\n    addEventListener: <TElement extends Pick<Element, 'addEventListener' | 'removeEventListener'>>(\r\n      el: TElement\r\n    ) => <TEventType extends string>(\r\n      type: TEventType\r\n    ) => (cb: EventHandler<TEventType>) => T.Effect<unknown, unknown, never, void>;\r\n  };\r\n}\r\n\r\n// Events\r\nexport const subscribe = <TEventType extends string>(type: TEventType, ret?: any) => <\r\n  TElement extends  Pick<Element, 'addEventListener' | 'removeEventListener'>\r\n>(\r\n  el?: TElement\r\n) => {\r\n  return S.fromSource(\r\n    M.managed.chain(\r\n      M.bracket(\r\n        T.accessM((_: Emitter) =>\r\n          T.sync(() => {\r\n            const { next, ops, hasCB } = S.su.queueUtils<\r\n              never,\r\n              EventFor<TEventType>\r\n            >();\r\n\r\n            const fn = el ? _[uri].addEventListener(el) : _[uri].fromEvent;\r\n\r\n            return {\r\n              unsubscribe: fn(type)(a => {\r\n                next({ _tag: \"offer\", a })\r\n                return ret\r\n              }),\r\n              ops,\r\n              hasCB\r\n            };\r\n          })\r\n        ),\r\n        _ => _.unsubscribe\r\n      ),\r\n      ({ ops, hasCB }) => S.su.emitter(ops, hasCB)\r\n    )\r\n  );\r\n};\r\n\r\nexport const makeEmitterLive = <\r\n  TRoot extends Pick<Element, \"addEventListener\" | \"removeEventListener\">\r\n>(\r\n  rootEl: TRoot\r\n): Emitter => {\r\n  return {\r\n    [uri]: {\r\n      fromEvent: <TEventType extends string>(type: TEventType) => (\r\n        cb: EventHandler<TEventType>\r\n      ) => {\r\n        const wrappedCb = (e: EventFor<TEventType>) => {\r\n          e.stopPropagation();\r\n          return cb(e);\r\n        };\r\n        rootEl.addEventListener(type, wrappedCb as any);\r\n\r\n        return T.sync(() => rootEl.removeEventListener(type, cb as any));\r\n      },\r\n      addEventListener: <TElement extends Pick<Element, 'addEventListener' | 'removeEventListener'>>(el: TElement) => <\r\n        TEventType extends string\r\n      >(\r\n        type: TEventType\r\n      ) => (cb: EventHandler<TEventType>) => {\r\n        const wrappedCb = (e: EventFor<TEventType>) => {\r\n          e.stopPropagation();\r\n          return cb(e);\r\n        };\r\n        el.addEventListener(type, wrappedCb as any);\r\n\r\n        return T.sync(() => el.removeEventListener(type, cb as any));\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * waitForKeyPress :: number -> Effect NoEnv never void\r\n *\r\n * Given a keyCode returns an effect that resolves once the user\r\n * presses a key on the keyboard matching the key code.\r\n */\r\nexport const waitForKeyPress = (...keyCodes: number[]) =>\r\n  T.effect.chain(log(\"Waiting for \", ...keyCodes), () =>\r\n    pipe(\r\n      subscribe(\"keyup\")(),\r\n      S.filter(event => keyCodes.includes(event.keyCode)),\r\n      S.take(1),\r\n      S.collectArray,\r\n      T.map(([evt]) => evt)\r\n    )\r\n  );\r\n","import { effect as T } from \"@matechs/effect\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport {  flow } from \"fp-ts/lib/function\";\r\n\r\nexport const documentUri = \"@uri/document\";\r\n\r\nexport type DocumentEnv = { [documentUri]: Document };\r\n\r\nexport const documentLive = {\r\n  [documentUri]: document,\r\n};\r\n\r\nexport const provideDocument = T.provide(documentLive);\r\n\r\nexport const getDocument = T.accessM(\r\n  flow((_: DocumentEnv) => _[documentUri], T.pure)\r\n);\r\n\r\nexport const mapDocument = <R, E, A>(f: (doc: Document) => T.Effect<unknown, R, E, A>) =>\r\n  pipe(getDocument, T.map(f));\r\n","import { effect as T, stream as S } from \"@matechs/effect\";\r\n\r\nimport * as O from \"fp-ts/lib/Option\";\r\nimport * as A from \"fp-ts/lib/ReadonlyArray\";\r\nimport * as Eq from \"fp-ts/lib/Eq\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport {\r\n  constant,\r\n  identity,\r\n  flow,\r\n  constVoid,\r\n  tuple,\r\n  constTrue,\r\n} from \"fp-ts/lib/function\";\r\n\r\nimport * as t from \"io-ts\";\r\nimport { Do } from \"fp-ts-contrib/lib/Do\";\r\n\r\nimport {\r\n  createElement,\r\n  querySelector,\r\n  makeElementNotFound,\r\n  $,\r\n  parentElement,\r\n  makeParentElementNotFound,\r\n  Dom,\r\n} from \"./dom\";\r\nimport * as Fetch from \"./fetch\";\r\nimport { subscribe, Emitter } from \"./emitter\";\r\nimport { store, Store } from \"./store\";\r\nimport { log, Console } from \"@matechs/console\";\r\n\r\n/**\r\n * ```hs\r\n *\r\n * URL :: string\r\n *\r\n * ```\r\n *\r\n * API URL where a list of todo objects is requested from\r\n */\r\nconst URL = \"https://jsonplaceholder.typicode.com/todos\";\r\n\r\n/**\r\n * ```hs\r\n *\r\n * Todo :: t.TypeC<Todo>\r\n *\r\n * ```\r\n *\r\n * io-ts decoder for Todo\r\n */\r\nconst todoDecoder = t.type(\r\n  {\r\n    id: t.number,\r\n    userId: t.number,\r\n    title: t.string,\r\n    completed: t.boolean,\r\n  },\r\n  \"Todo\"\r\n);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * Todos :: t.TypeC<Todos>\r\n *\r\n * ```\r\n *\r\n * io-ts decoder for a list of [[Todo]]\r\n */\r\nconst todosDecoder = t.readonlyArray(todoDecoder);\r\n\r\n// Types\r\ntype Todo = t.TypeOf<typeof todoDecoder>;\r\n\r\ntype Todos = readonly Todo[];\r\n\r\nconst eqTodoById = Eq.contramap((todo: Todo) => todo.id)(Eq.eqNumber);\r\n\r\n// Store (environment)\r\nconst uri = \"@uri/todo-store\";\r\n\r\ninterface TodosState {\r\n  todos: Todos;\r\n  filterBy: \"all\" | \"active\" | \"completed\";\r\n  new: \"\";\r\n}\r\n\r\ntype TodosStore = Store<TodosState>;\r\n\r\ninterface TodoStoreEnv {\r\n  [uri]: TodosStore;\r\n}\r\n\r\n/**\r\n * ```hs\r\n *\r\n * todosStore :: Effect unknown never (Store Todos)\r\n *\r\n * ```\r\n *\r\n * You can update the list of todos by passing a callback function to store.next\r\n * or subscribe to store changes using the store.subscribe stream.\r\n */\r\nconst storeT = store<TodosState>({\r\n  todos: [],\r\n  filterBy: \"all\",\r\n  new: \"\",\r\n});\r\n\r\nconst provideTodoStore = T.provideM(\r\n  pipe(\r\n    storeT,\r\n    T.map((store) => ({ [uri]: store }))\r\n  )\r\n);\r\n\r\nconst todoStore = pipe(T.access((_: TodoStoreEnv) => _[uri]));\r\n\r\n// APIS\r\nconst fetchTodos = pipe(\r\n  // Fetch list of todos from the server\r\n  Fetch.fetch(URL),\r\n  // Decode the response\r\n  T.chain((response) => T.sync(() => todosDecoder.decode(response))),\r\n  // From Effect<R, E, Either<E2, Todos> to Effect<R, E | E2, Todos>\r\n  T.chain(T.fromEither)\r\n);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * html :: string\r\n *\r\n * ```\r\n *\r\n * HTML used to create a todo for\r\n */\r\nconst html = `<li>\r\n    <div class=\"view\">\r\n        <input data-toggle class=\"toggle\" type=\"checkbox\">\r\n        <label data-edit></label>\r\n        <button data-remove class=\"destroy\"></button>\r\n    </div>\r\n    <input class=\"edit\" />\r\n</li>`;\r\n\r\n// TODO: Use environment to produce div\r\nconst _div = createElement(\"div\");\r\n\r\n/**\r\n * ```hs\r\n *\r\n * createDomNodeForTodo :: Effect\r\n *\r\n * ```\r\n *\r\n * Create a dom element for a todo\r\n */\r\nconst createDomNodeForTodo = pipe(\r\n  _div,\r\n  T.chain((el) =>\r\n    T.sync(() => {\r\n      el.innerHTML = html;\r\n      return querySelector(\"li\")(el);\r\n    })\r\n  ),\r\n  T.chain(\r\n    T.fromOption(\r\n      constant(\r\n        makeElementNotFound(\"Unable to create DOM element for todo item.\")\r\n      )\r\n    )\r\n  )\r\n);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * todosUl :: Effect\r\n *\r\n * ```\r\n *\r\n * Select the ul dom node that contains the list of li nodes that are todo items.\r\n */\r\nconst todosUl = $<HTMLUListElement>(\".todo-list\");\r\n\r\n/**\r\n * ```hs\r\n *\r\n * updateDomNodeOfTodo :: Todo -> HTMLLIElement -> Effect\r\n *\r\n * ```\r\n *\r\n * Update a given todo dom li node with information from a [[Todo]] model\r\n */\r\nconst updateDomNodeOfTodo = (todo: Todo) => (todoLi: HTMLLIElement) =>\r\n  pipe(\r\n    Do(O.option)\r\n      // Select the input and label dom nodes that are inside the li node\r\n      .bind(\"label\", querySelector(\"label\")(todoLi))\r\n      .bind(\"checkbox\", querySelector(\"input\")(todoLi))\r\n      .bind(\"input\", querySelector<HTMLInputElement>(\"input.edit\")(todoLi))\r\n      .return(({ label, checkbox, input }) =>\r\n        T.sync(() => {\r\n          // Update title\r\n          label.innerHTML = todo.title;\r\n\r\n          // Add todo id as attribute\r\n          todoLi.setAttribute(\"data-todo-id\", \"\" + todo.id);\r\n\r\n          // Mark as completed if so\r\n          todo.completed\r\n            ? todoLi.classList.add(\"completed\")\r\n            : todoLi.classList.remove(\"completed\");\r\n          checkbox.checked = todo.completed;\r\n          input.value = todo.title;\r\n\r\n          return todoLi;\r\n        })\r\n      ),\r\n    // TODO: Handle if label or input aren't available\r\n    T.fromOption(constant(Error(\"\"))),\r\n    T.chain(identity)\r\n  );\r\n\r\nconst clickedTodoId = (target: HTMLElement) =>\r\n  pipe(\r\n    parentElement<HTMLElement, HTMLDivElement>(target),\r\n    O.chain((div) => parentElement<HTMLDivElement, HTMLLIElement>(div)),\r\n    T.pure,\r\n    T.chain(T.fromOption(constant(makeParentElementNotFound(target)))),\r\n    T.map((parent) =>\r\n      pipe(\r\n        parent.getAttribute(\"data-todo-id\"),\r\n        O.fromNullable,\r\n        O.map(Number),\r\n        O.map((todoId) => tuple(todoId, parent))\r\n      )\r\n    ),\r\n    T.chain(T.fromOption(constant(makeParentElementNotFound(target))))\r\n  );\r\n\r\n/**\r\n * ```hs\r\n *\r\n * handleEvents :: Effect\r\n *\r\n * ```\r\n *\r\n * Handle click events that indicate the user wants to:\r\n * - Remove the todo\r\n * - Toggle the todo's completed status\r\n * - Edit the todo's title\r\n *\r\n */\r\nconst handleEvents = pipe(\r\n  // With the root dom node that is the list of items\r\n  todosUl,\r\n  S.encaseEffect,\r\n  // Subscribe to clicking the list\r\n  S.chain(pipe(subscribe(\"click\"))),\r\n  // Map the mouse event to the target (currentTarget would be the list, we want what the user actually clicked.)\r\n  S.map((_) => _.target),\r\n  S.map(O.fromNullable),\r\n  S.chain(S.fromOption),\r\n  S.chain((_) => {\r\n    const target = _ as HTMLElement;\r\n\r\n    const todoIdEffect = clickedTodoId(target);\r\n\r\n    // Clicking the remove button (red x on hover)\r\n    if (target.hasAttribute(\"data-remove\")) {\r\n      return pipe(\r\n        todoIdEffect,\r\n        T.zip(todoStore),\r\n        T.chain(([[todoId], store]) =>\r\n          store.next((state) => {\r\n            return {\r\n              ...state,\r\n              todos: state.todos.filter((todo) => todo.id !== todoId),\r\n            };\r\n          })\r\n        ),\r\n        S.encaseEffect\r\n      );\r\n\r\n      // Clicking the toggle \"completed\" checkbox\r\n    } else if (target.hasAttribute(\"data-toggle\")) {\r\n      return pipe(\r\n        todoIdEffect,\r\n        T.zip(todoStore),\r\n        T.chain(([[todoId], store]) =>\r\n          store.next((state) => {\r\n            return {\r\n              ...state,\r\n              todos: state.todos.map((todo) =>\r\n                todo.id === todoId\r\n                  ? { ...todo, completed: !todo.completed }\r\n                  : todo\r\n              ),\r\n            };\r\n          })\r\n        ),\r\n        S.encaseEffect\r\n      );\r\n\r\n      // Clicking the label to edit the title\r\n    } else if (target.hasAttribute(\"data-edit\")) {\r\n      return pipe(\r\n        todoIdEffect,\r\n        T.chain(([todoId, li]) => {\r\n          // Makes the text input box visible\r\n          const addClass = T.sync(() => {\r\n            li.classList.add(\"editing\");\r\n          });\r\n\r\n          // Hides the text input box\r\n          const removeClass = T.sync(() => {\r\n            li.classList.remove(\"editing\");\r\n          });\r\n\r\n          const input = pipe(\r\n            li,\r\n            querySelector<HTMLInputElement>(\"input.edit\"),\r\n            T.fromOption(constant(makeElementNotFound(\"li>input\"))),\r\n            T.chain((input) => {\r\n              // Gives the text input box focus and selects the text\r\n              const setFocus = T.sync(() => {\r\n                input.focus();\r\n                input.select();\r\n              });\r\n\r\n              // Executes when the text input box looses focus\r\n              // Will hide the text input box\r\n              const handleBlur = pipe(\r\n                input,\r\n                subscribe(\"blur\"),\r\n                S.take(1),\r\n                S.drain,\r\n                T.zip(removeClass)\r\n              );\r\n\r\n              // Updates the store on every keystroke\r\n              const handlTextInput = pipe(\r\n                input,\r\n                // Listen to the text input's \"oninput\" event\r\n                subscribe(\"input\"),\r\n                S.chain(\r\n                  constant(\r\n                    pipe(\r\n                      todoStore,\r\n                      // Update the title of the todo in the store\r\n                      T.chain((store) =>\r\n                        store.next((state) => ({\r\n                          ...state,\r\n                          todos: state.todos.map((todo) =>\r\n                            todo.id === todoId\r\n                              ? { ...todo, title: input.value }\r\n                              : todo\r\n                          ),\r\n                        }))\r\n                      ),\r\n                      S.encaseEffect\r\n                    )\r\n                  )\r\n                ),\r\n                // Do this until the text input box looses focus\r\n                S.takeUntil(handleBlur),\r\n                S.drain\r\n              );\r\n\r\n              return pipe(setFocus, T.zip(handlTextInput));\r\n            })\r\n          );\r\n\r\n          return pipe(addClass, T.zip(input));\r\n        }),\r\n        S.encaseEffect\r\n      );\r\n    }\r\n\r\n    return S.encaseEffect(T.pure(constVoid()));\r\n  }),\r\n  S.drain\r\n);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * replaceTodosInStore :: [Todo] => Effect\r\n *\r\n * ```\r\n */\r\nconst replaceTodosInStore = (todos: Todos) =>\r\n  pipe(\r\n    todoStore,\r\n    T.chain((store) => store.next((state) => ({ ...state, todos })))\r\n  );\r\n\r\n/**\r\n * ```hs\r\n *\r\n * fetchAndStoreTodos :: Effect\r\n *\r\n * ```\r\n *\r\n * Fetch todo items from the server and replace the store with them.\r\n */\r\nconst fetchAndStoreTodos = pipe(fetchTodos, T.chain(replaceTodosInStore));\r\n\r\nconst logChanges = T.Do()\r\n  .bind(\"store\", todoStore)\r\n  .bindL(\"subscription\", ({ store }) => store.subscribe)\r\n  .doL(({ subscription }) =>\r\n    pipe(subscription, S.chain(flow(log, S.encaseEffect)), S.drain)\r\n  )\r\n  .return(constVoid);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * emptyListOfTodos :: [Todo]\r\n *\r\n * ```\r\n *\r\n */\r\nconst emptyListOfTodos: Todos = [];\r\n\r\n/**\r\n * ```hs\r\n *\r\n * getTodosDifference :: [Todo] -> [Todo] -> [Todo]\r\n *\r\n * ```\r\n *\r\n * Return todos from list a that are not in list b.\r\n * This is used to remove dom nodes of deleted todos\r\n *\r\n */\r\nconst getTodosDifference = A.difference(eqTodoById);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * removeTodosFromDom :: [Todo] -> Effect\r\n *\r\n * ```\r\n *\r\n * For each todo, remove it's related dom node if present.\r\n *\r\n */\r\nconst removeTodosFromDom = (todos: Todos) =>\r\n  pipe(\r\n    todos,\r\n    A.map((todo) =>\r\n      pipe(\r\n        // Find the dom node\r\n        $<HTMLLIElement>(`[data-todo-id=\"${todo.id}\"]`),\r\n        // Remove it from the dom\r\n        T.chain((li) => T.sync(li.remove.bind(li)))\r\n      )\r\n    ),\r\n    A.readonlyArray.sequence(T.effect)\r\n  );\r\n\r\n/**\r\n * ```hs\r\n *\r\n * optionOfPreviousTodoInDom :: Effect (Option HTMLLIElement)\r\n *\r\n * ```\r\n *\r\n * Initial \"previous sibling\". Used as the initial value when reducing a list of todos\r\n * into a single effect updating the dom\r\n *\r\n */\r\nconst optionOfPreviousTodoInDom: T.Effect<\r\n  unknown,\r\n  Console & Dom,\r\n  ReturnType<typeof makeElementNotFound> | Error,\r\n  O.Option<HTMLLIElement>\r\n> = T.pure(O.none);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * createAndUpdateTodoNode :: HTMLUListElement -> Effect (Option HTMLLIElement) -> Effect HTMLLIElement\r\n *\r\n * ```\r\n *\r\n * Creates new dom nodes for todos that are not yet present in the dom\r\n * and updates dom nodes of other todos\r\n *\r\n */\r\nconst createAndUpdateTodoNode = (ul: HTMLUListElement) => (\r\n  domNodeOfPreviousTodoInList: O.Option<HTMLLIElement>\r\n) => (todo: Todo) =>\r\n  pipe(\r\n    // Create a dom node\r\n    createDomNodeForTodo,\r\n    // Update it with information from the todo\r\n    T.chain(updateDomNodeOfTodo(todo)),\r\n    // Get the dom node it should attach itself to if available\r\n    // With the new dom node and it's \"previous sibling\"\r\n    T.chainTap((li) =>\r\n      pipe(\r\n        domNodeOfPreviousTodoInList,\r\n        O.fold(\r\n          // Prepend the dom node to the start of the list if no previous sibling is available\r\n          constant(T.sync(() => ul.prepend(li))),\r\n          // Other wise attach it after it's sibling\r\n          (domNodeOfPreviousTodoInList) =>\r\n            T.sync(() => domNodeOfPreviousTodoInList.after(li))\r\n        )\r\n      )\r\n    )\r\n  );\r\n\r\n/**\r\n * ```hs\r\n *\r\n * updateDomWithTodos :: HTMLUListElement -> [Todo] -> Effect\r\n *\r\n * ```\r\n *\r\n * Creates new dom nodes for todos that are not yet present in the dom\r\n * and updates dom nodes of other todos\r\n *\r\n */\r\nconst updateDomWithTodos = (ul: HTMLUListElement) => (todos: Todos) =>\r\n  pipe(\r\n    todos,\r\n    // Reduce the list of todos into a single effect\r\n    A.reduce(optionOfPreviousTodoInDom, (acc, todo) =>\r\n      pipe(\r\n        // Chain over the previous effect\r\n        acc,\r\n        T.chain((optionOfSiblingTodoInDom) =>\r\n          pipe(\r\n            ul,\r\n            querySelector<HTMLLIElement>(`[data-todo-id=\"${todo.id}\"]`),\r\n            O.fold(\r\n              // Create a dom node for new todos\r\n              // The accumulated effect is passed so that\r\n              // new dom nodes can attach themselves after the previous one\r\n              constant(\r\n                createAndUpdateTodoNode(ul)(optionOfSiblingTodoInDom)(todo)\r\n              ),\r\n              // Or if a dom node was found, update it\r\n              updateDomNodeOfTodo(todo)\r\n            ),\r\n            T.map(O.some)\r\n          )\r\n        )\r\n      )\r\n    )\r\n  );\r\n\r\n/**\r\n * ```hs\r\n *\r\n * commitStoreUpdatesToDom :: Effect\r\n *\r\n * ```\r\n *\r\n * Subscribes to store changes and updates the dom.\r\n *\r\n */\r\nconst commitStoreUpdatesToDom = T.Do()\r\n  .bind(\"store\", todoStore)\r\n  .bindL(\"subscription\", ({ store }) => store.subscribe)\r\n  .bind(\"ul\", todosUl)\r\n  // With store subscription and root dom node do:\r\n  .doL(({ subscription, ul }) =>\r\n    pipe(\r\n      subscription,\r\n      S.map((state) =>\r\n        state.filterBy === \"all\"\r\n          ? state.todos\r\n          : pipe(\r\n              state.todos,\r\n              A.filter((todo) =>\r\n                state.filterBy === \"completed\"\r\n                  ? todo.completed\r\n                  : !todo.completed\r\n              )\r\n            )\r\n      ),\r\n      // Take 10 todo items at a time\r\n      S.map(A.takeLeft(10)),\r\n      // Keep track of previous list to use for comparison\r\n      S.scan(tuple(emptyListOfTodos, emptyListOfTodos), ([prev], next) =>\r\n        tuple(next, prev)\r\n      ),\r\n      S.chain(([next, prev]) =>\r\n        S.encaseEffect(\r\n          pipe(\r\n            // Remove todos that were in the previous list but not in the next\r\n            removeTodosFromDom(getTodosDifference(prev, next)),\r\n            // Add todos to the dom that are in the new list but weren't in the previous\r\n            // or update nodes with new information\r\n            T.zip(updateDomWithTodos(ul)(next))\r\n          )\r\n        )\r\n      ),\r\n      S.drain\r\n    )\r\n  )\r\n  .return(constVoid);\r\n\r\nconst updateCounter = pipe(\r\n  todoStore,\r\n  T.chain((store) => store.subscribe),\r\n  S.encaseEffect,\r\n  S.chain(identity),\r\n  S.map((state) => state.todos),\r\n  S.map((todos) =>\r\n    pipe(\r\n      todos,\r\n      A.filter((todo) => !todo.completed)\r\n    )\r\n  ),\r\n  S.map((todos) => todos.length),\r\n  S.chain((itemsLeft) =>\r\n    S.encaseEffect(\r\n      pipe(\r\n        $(\".todo-count\"),\r\n        T.map(querySelector(\"strong\")),\r\n        T.chain(\r\n          T.fromOption(constant(makeElementNotFound(\".todo-count > strong\")))\r\n        ),\r\n        T.chain((el) =>\r\n          T.sync(() => {\r\n            el.innerHTML = \"\" + itemsLeft;\r\n          })\r\n        )\r\n      )\r\n    )\r\n  ),\r\n  S.drain\r\n);\r\n\r\nconst makeHandleFilter = (filterBy: \"all\" | \"active\" | \"completed\") =>\r\n  pipe(\r\n    $<HTMLAnchorElement>(`#btn-filter-${filterBy}`),\r\n    S.encaseEffect,\r\n    S.chain(subscribe(\"click\")),\r\n    S.chain(\r\n      constant(\r\n        S.encaseEffect(\r\n          pipe(\r\n            T.parSequenceT(\r\n              $<HTMLAnchorElement>(`#btn-filter-all`),\r\n              $<HTMLAnchorElement>(`#btn-filter-active`),\r\n              $<HTMLAnchorElement>(`#btn-filter-completed`)\r\n            ),\r\n            T.chain((links) =>\r\n              T.sync(() => {\r\n                links.forEach((link) => link.classList.remove(\"selected\"));\r\n              })\r\n            )\r\n          )\r\n        )\r\n      )\r\n    ),\r\n    S.chain(\r\n      constant(\r\n        S.encaseEffect(\r\n          pipe(\r\n            todoStore,\r\n            T.chain((store) => store.next((state) => ({ ...state, filterBy })))\r\n          )\r\n        )\r\n      )\r\n    ),\r\n    S.chain(\r\n      constant(\r\n        S.encaseEffect(\r\n          pipe(\r\n            $<HTMLAnchorElement>(`#btn-filter-${filterBy}`),\r\n            T.chain((link) =>\r\n              T.sync(() => {\r\n                link.classList.add(\"selected\");\r\n              })\r\n            )\r\n          )\r\n        )\r\n      )\r\n    ),\r\n    S.drain\r\n  );\r\n\r\nconst handleClearCompleted = pipe(\r\n  $<HTMLButtonElement>(`.clear-completed`),\r\n  S.encaseEffect,\r\n  S.chain(subscribe(\"click\")),\r\n  S.chain(\r\n    constant(\r\n      S.encaseEffect(\r\n        pipe(\r\n          todoStore,\r\n          T.chain((store) =>\r\n            store.next((state) => ({\r\n              ...state,\r\n              todos: pipe(\r\n                state.todos,\r\n                A.filter((todo) => !todo.completed)\r\n              ),\r\n            }))\r\n          )\r\n        )\r\n      )\r\n    )\r\n  ),\r\n  S.drain\r\n);\r\n\r\nconst handleNewTodos = pipe(\r\n  $<HTMLInputElement>(\".new-todo\"),\r\n  S.encaseEffect,\r\n  S.chain(subscribe(\"keyup\")),\r\n  S.filter((event) => event.key === \"Enter\"),\r\n  S.map((event) => event.currentTarget as HTMLInputElement | null),\r\n  S.map(O.fromNullable),\r\n  S.chain(S.fromOption),\r\n  S.filter((input) => !!input.value.trim()),\r\n  S.chain((input) =>\r\n    S.encaseEffect(\r\n      pipe(\r\n        todoStore,\r\n        T.chain((store) =>\r\n          store.next((state) => ({\r\n            ...state,\r\n            todos: [\r\n              {\r\n                id: Math.random(),\r\n                title: input.value,\r\n                completed: false,\r\n                userId: Math.random(),\r\n              },\r\n              ...state.todos,\r\n            ],\r\n          }))\r\n        ),\r\n        T.chain(\r\n          constant(\r\n            T.sync(() => {\r\n              input.value = \"\";\r\n            })\r\n          )\r\n        )\r\n      )\r\n    )\r\n  ),\r\n  S.drain\r\n);\r\n\r\nconst allTodosAreCompleted = (todos: Todos): boolean =>\r\n  pipe(\r\n    todos,\r\n    A.foldLeft(\r\n      constTrue,\r\n      (todo, rest) => todo.completed && allTodosAreCompleted(rest)\r\n    )\r\n  );\r\n\r\nconst handleMarkAllAsCompleted = pipe(\r\n  $<HTMLInputElement>(\"#toggle-all\"),\r\n  T.zip(todoStore),\r\n  T.chain(([input, store]) =>\r\n    pipe(\r\n      store.subscribe,\r\n      T.map((susbscription) => tuple(input, store, susbscription))\r\n    )\r\n  ),\r\n  S.encaseEffect,\r\n  S.chain(\r\n    ([input, store, susbscription]) => {\r\n      const stateS: S.AsyncR<Emitter, void> = pipe(\r\n        susbscription,\r\n        S.map((state) =>\r\n          state.filterBy === \"all\"\r\n            ? state.todos\r\n            : pipe(\r\n                state.todos,\r\n                A.filter((todo) =>\r\n                  state.filterBy === \"completed\"\r\n                    ? todo.completed\r\n                    : !todo.completed\r\n                )\r\n              )\r\n        ),\r\n        // Take 10 todo items at a time\r\n        S.map(A.takeLeft(10)),\r\n        S.map((todos) => tuple(allTodosAreCompleted(todos), todos)),\r\n        S.chain(([allCompleted, todos]) =>\r\n          S.encaseEffect(\r\n            T.sync(() => {\r\n              input.checked = allCompleted;\r\n            })\r\n          )\r\n        ),\r\n        S.map(constVoid)\r\n      );\r\n\r\n      const clickS = pipe(\r\n        subscribe(\"click\")(input),\r\n        S.chain(\r\n          constant(\r\n            S.encaseEffect(\r\n              pipe(\r\n                store.get,\r\n                T.chain((stateO) =>\r\n                  pipe(\r\n                    stateO,\r\n                    O.map((state) => {\r\n                      const todosListed = pipe(\r\n                        state.filterBy === \"all\"\r\n                          ? state.todos\r\n                          : pipe(\r\n                              state.todos,\r\n                              A.filter((todo) =>\r\n                                state.filterBy === \"completed\"\r\n                                  ? todo.completed\r\n                                  : !todo.completed\r\n                              )\r\n                            ),\r\n                        A.takeLeft(10)\r\n                      );\r\n\r\n                      const completed = !allTodosAreCompleted(todosListed);\r\n\r\n                      return store.next((state) => ({\r\n                        ...state,\r\n                        todos: state.todos.map((todo) =>\r\n                          pipe(\r\n                            todosListed,\r\n                            A.findFirstMap((listedTodo) =>\r\n                              listedTodo.id !== todo.id\r\n                                ? O.none\r\n                                : O.some({ ...todo, completed })\r\n                            ),\r\n                            O.fold(constant(todo), identity)\r\n                          )\r\n                        ),\r\n                      }));\r\n                    }),\r\n                    O.getOrElse<T.Async<void>>(constant(T.sync(constVoid)))\r\n                  )\r\n                )\r\n              )\r\n            )\r\n          )\r\n        ),\r\n        S.map(constVoid)\r\n      );\r\n\r\n      const merged = S.mergeAll([stateS, clickS]);\r\n\r\n      return pipe(merged);\r\n    }\r\n    /*\r\n    pipe(\r\n      susbscription,\r\n      S.map((state) =>\r\n        state.filterBy === \"all\"\r\n          ? state.todos\r\n          : pipe(\r\n              state.todos,\r\n              A.filter((todo) =>\r\n                state.filterBy === \"completed\"\r\n                  ? todo.completed\r\n                  : !todo.completed\r\n              )\r\n            )\r\n      ),\r\n      // Take 10 todo items at a time\r\n      S.map(A.takeLeft(10)),\r\n      S.map((todos) => tuple(allTodosAreCompleted(todos), todos)),\r\n      S.chain(([allCompleted, todos]) =>\r\n        S.encaseEffect(\r\n          T.sync(() => {\r\n            input.checked = allCompleted;\r\n            return tuple(allCompleted, todos);\r\n          })\r\n        )\r\n      ),\r\n      S.chain(([allCompleted, todosListed]) => {\r\n        debugger;\r\n        return pipe(\r\n          subscribe(\"click\")(input),\r\n          S.take(1),\r\n          S.chain(() =>\r\n            S.encaseEffect(\r\n              store.next((state) => ({\r\n                ...state,\r\n                todos: state.todos.map((todo) =>\r\n                  pipe(\r\n                    todosListed,\r\n                    A.findFirstMap((listedTodo) =>\r\n                      listedTodo.id !== todo.id\r\n                        ? O.none\r\n                        : O.some({ ...todo, completed: !allCompleted })\r\n                    ),\r\n                    O.fold(constant(todo), identity)\r\n                  )\r\n                ),\r\n              }))\r\n            )\r\n          )\r\n        );\r\n      })\r\n    )*/\r\n  ),\r\n  S.drain\r\n);\r\n/**\r\n * ```hs\r\n *\r\n * main :: Effect\r\n *\r\n * ```\r\n *\r\n * TodoMVC Program\r\n */\r\nexport const main = pipe(\r\n  T.parSequenceT(\r\n    logChanges,\r\n    fetchAndStoreTodos,\r\n    handleEvents,\r\n    commitStoreUpdatesToDom,\r\n    updateCounter,\r\n    makeHandleFilter(\"all\"),\r\n    makeHandleFilter(\"active\"),\r\n    makeHandleFilter(\"completed\"),\r\n    handleNewTodos,\r\n    handleClearCompleted,\r\n    handleMarkAllAsCompleted\r\n  ),\r\n  provideTodoStore\r\n);\r\n","import * as serviceWorker from \"./serviceWorker\";\nimport \"./index.scss\";\n\nimport { effect as T } from \"@matechs/effect\";\nimport { provideConsole } from \"@matechs/console\";\n\nimport { pipe } from \"fp-ts/lib/pipeable\";\n\nimport * as Todo from \"./modules/todo\";\nimport { provideDom } from \"./modules/dom\";\nimport { provideDocument } from \"./modules/document\";\nimport * as Fetch from \"./modules/fetch\";\n\nimport { makeEmitterLive } from \"./modules/emitter\";\n\n\nconst provided = pipe(\n    // Run the main todo program\n  Todo.main,\n  // Provide DOM utilities\n  provideDom,\n  // Provide document object\n  provideDocument,\n  // Provide window.fetch\n  Fetch.provideFetch,\n  // Provide logging capabilities\n  provideConsole,\n  // Provide event emitter with root element\n  T.provide(makeEmitterLive(document)),\n  // Provide depracated thing\n  // T.provide({\n  //   [T.AsyncRTURI]: {},\n  // }),\n);\n\nT.runToPromise(provided)\n  .then((foo) => console.log(\"Done\", foo))\n  .catch((error) => {\n    console.error(error);\n  });\n  \n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}