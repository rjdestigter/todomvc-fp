{"version":3,"sources":["serviceWorker.ts","modules/dom.ts","modules/store.ts","modules/fetch.ts","modules/emitter.ts","modules/document.ts","modules/todo.ts","index.ts"],"names":["Boolean","window","location","hostname","match","eventType","initial","input","init","tagName","options","rootEl","uri","subscribe","type","ret","el","S","fromSource","M","managed","chain","bracket","T","accessM","_","sync","su","queueUtils","next","ops","hasCB","unsubscribe","addEventListener","fromEvent","fn","a","_tag","emitter","documentLive","document","provideDocument","provide","getDocument","flow","pure","domLive","createElement","provideDom","ElementNotFound","selectors","name","Error","ParentElementNotFound","child","makeElementNotFound","makeParentElementNotFound","raiseError","element","toString","querySelector","O","$","pipe","map","fromOption","constant","parentElement","node","EmptyOptionOfElement","message","fetchLive","fetch","args","Promise","resolve","setTimeout","bind","provideFetch","FetchFailed","info","makeFetchFailed","url","error","todoDecoder","t","id","userId","title","completed","todosDecoder","eqTodoById","Eq","todo","storeT","Q","unboundedQueue","zip","ref","makeRef","queue","state","f","update","current","offer","subject","take","s","provideTodoStore","provideM","store","todoStore","access","fetchTodos","async","r","then","response","json","E","cb","decode","fromEither","_div","createDomNodeForTodo","innerHTML","todosUl","updateDomNodeOfTodo","todoLi","Do","return","label","checkbox","setAttribute","classList","add","checked","value","identity","handleEvents","encaseEffect","target","todoIdEffect","div","parent","getAttribute","Number","todoId","tuple","clickedTodoId","hasAttribute","todos","filter","li","addClass","removeClass","remove","setFocus","focus","select","handleBlur","drain","handlTextInput","takeUntil","constVoid","fetchAndStoreTodos","logChanges","bindL","doL","subscription","log","emptyListOfTodos","getTodosDifference","A","optionOfPreviousTodoInDom","updateDomWithTodos","ul","acc","optionOfSiblingTodoInDom","domNodeOfPreviousTodoInList","chainTap","prepend","after","createAndUpdateTodoNode","commitStoreUpdatesToDom","scan","prev","sequence","effect","main","parZip","provided","Todo","Fetch","provideConsole","e","stopPropagation","removeEventListener","runToPromise","foo","console","catch","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.1e2b3609.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL || '',\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import { effect as T, stream as S } from \"@matechs/effect\";\r\nimport * as O from \"fp-ts/lib/Option\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { constant, flow, identity } from \"fp-ts/lib/function\";\r\nimport { subscribe, Emitter, EventFor } from \"./emitter\";\r\nimport { DocumentEnv, getDocument } from \"./document\";\r\n\r\n/**\r\n * Environment\r\n */\r\nexport const uri = \"@uri/dom\";\r\n\r\nexport interface Dom {\r\n  [uri]: {\r\n    createElement<K extends keyof HTMLElementTagNameMap>(\r\n      tagName: K,\r\n      options?: ElementCreationOptions\r\n    ): HTMLElementTagNameMap[K];\r\n    createElement(\r\n      tagName: string,\r\n      options?: ElementCreationOptions\r\n    ): HTMLElement;\r\n  };\r\n}\r\n\r\nexport const domLive: Dom = {\r\n  [uri]: {\r\n    createElement: (tagName: any, options?: ElementCreationOptions) =>\r\n      document.createElement(tagName, options),\r\n  },\r\n};\r\n\r\nexport const provideDom = T.provide(domLive);\r\n\r\n/**\r\n * Errors\r\n */\r\nclass ElementNotFound extends Error {\r\n  constructor(selectors: string) {\r\n    super(`$(${selectors}) did not return an element.`);\r\n    this.name = \"ElementNotFound\";\r\n  }\r\n}\r\n\r\nclass ParentElementNotFound extends Error {\r\n  constructor(child: string) {\r\n    super(`Parent of node: ${child} not found.`);\r\n    this.name = \"ParentElementNotFound\";\r\n  }\r\n}\r\n\r\nexport const makeElementNotFound = (selectors: string) =>\r\n  new ElementNotFound(selectors);\r\n\r\nexport const raiseElementNotFound = flow(makeElementNotFound, T.raiseError);\r\n\r\nexport const makeParentElementNotFound = (element: HTMLElement) =>\r\n  new ParentElementNotFound(element.toString());\r\n\r\nexport const raiseParentElementNotFound = flow(\r\n  makeParentElementNotFound,\r\n  T.raiseError\r\n);\r\n\r\n/**\r\n * Utilities\r\n */\r\ninterface CreateElement {\r\n  <K extends keyof HTMLElementTagNameMap>(\r\n    tagName: K,\r\n    options?: ElementCreationOptions\r\n  ): T.Effect<unknown, Dom, never, HTMLElementTagNameMap[K]>;\r\n  (tagName: string, options?: ElementCreationOptions): T.Effect<\r\n    unknown,\r\n    Dom,\r\n    never,\r\n    HTMLElement\r\n  >;\r\n}\r\n\r\nexport const createElement: CreateElement = (\r\n  tagName: string,\r\n  options?: ElementCreationOptions\r\n) => T.accessM((_: Dom) => T.pure(_[uri].createElement(tagName, options)));\r\n\r\n/**\r\n * QuerySelector\r\n */\r\ninterface QuerySelector {\r\n  <K extends keyof HTMLElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: TNode\r\n  ) => O.Option<HTMLElementTagNameMap[K]>;\r\n  <K extends keyof SVGElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: TNode\r\n  ) => O.Option<SVGElementTagNameMap[K]>;\r\n  <E extends Element = Element>(selectors: string): <TNode extends ParentNode>(\r\n    node: TNode\r\n  ) => O.Option<E>;\r\n}\r\n\r\ninterface QuerySelectorT {\r\n  <K extends keyof HTMLElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: O.Option<TNode>\r\n  ) => O.Option<HTMLElementTagNameMap[K]>;\r\n  <K extends keyof SVGElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: O.Option<TNode>\r\n  ) => O.Option<SVGElementTagNameMap[K]>;\r\n  <E extends Element = Element>(selectors: string): <TNode extends ParentNode>(\r\n    node: O.Option<TNode>\r\n  ) => O.Option<E>;\r\n}\r\n\r\nexport const querySelector: QuerySelector = (selectors: string) => <\r\n  TNode extends ParentNode\r\n>(\r\n  el: TNode\r\n) => O.fromNullable(el.querySelector(selectors));\r\n\r\nexport const querySelectorO: QuerySelectorT = (selectors: string) => <\r\n  TNode extends ParentNode\r\n>(\r\n  nodeOT: O.Option<TNode>\r\n) =>\r\n  pipe(\r\n    nodeOT,\r\n    O.map((el) => querySelector(selectors)(el))\r\n  );\r\n\r\n/**\r\n * $\r\n */\r\ninterface $ {\r\n  <K extends keyof HTMLElementTagNameMap>(selectors: K): T.Effect<\r\n    unknown,\r\n    DocumentEnv,\r\n    ElementNotFound,\r\n    HTMLElementTagNameMap[K]\r\n  >;\r\n  <K extends keyof SVGElementTagNameMap>(selectors: K): T.Effect<\r\n    unknown,\r\n    DocumentEnv,\r\n    ElementNotFound,\r\n    SVGElementTagNameMap[K]\r\n  >;\r\n  <E extends Element = Element>(selectors: string): T.Effect<\r\n    unknown,\r\n    DocumentEnv,\r\n    ElementNotFound,\r\n    E\r\n  >;\r\n}\r\n\r\nexport const $: $ = (selectors: string) =>\r\n  pipe(\r\n    getDocument,\r\n    T.map(querySelector(selectors)),\r\n    T.chain(T.fromOption(constant(makeElementNotFound(selectors))))\r\n  );\r\n\r\n/**\r\n * ```hs\r\n * parentElement :: Node -> Option<HTMLelement>\r\n * ```\r\n */\r\nexport const parentElement = <TNode extends Node, TParentNode extends Node>(\r\n  node: TNode\r\n) => O.fromNullable(node.parentElement as TParentNode | null);\r\n\r\nexport class EmptyOptionOfElement extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = \"EmptyOptionOfElement\";\r\n  }\r\n}\r\n\r\nexport const raiseEmptyOptionOfElement = (message: string) =>\r\n  T.raiseError(new EmptyOptionOfElement(message));\r\n\r\nexport const makeEventStream = <TEventType extends string>(\r\n  eventType: TEventType\r\n) => <\r\n  R,\r\n  E,\r\n  A extends Pick<Element, \"addEventListener\" | \"removeEventListener\">\r\n>(\r\n  elementT: T.Effect<unknown, R, E, O.Option<A>>\r\n) =>\r\n  pipe(\r\n    elementT,\r\n    T.map((elementO) =>\r\n      pipe(\r\n        elementO,\r\n        O.map(subscribe(eventType)),\r\n        (effect) => effect,\r\n        O.fold<\r\n          S.Stream<unknown, Emitter, never, EventFor<TEventType>>,\r\n          S.Stream<unknown, Emitter, EmptyOptionOfElement, EventFor<TEventType>>\r\n        >(\r\n          constant(\r\n            S.raised(\r\n              new EmptyOptionOfElement(\r\n                `Option does not contain some element to create ${eventType} event stream for`\r\n              )\r\n            )\r\n          ),\r\n          identity\r\n        )\r\n      )\r\n    )\r\n  );\r\n\r\nexport const makeClickStream = makeEventStream(\"click\");\r\n","import {\r\n  effect as T,\r\n  ref,\r\n  stream as S,\r\n  queue as Q,\r\n  managed as M,\r\n} from \"@matechs/effect\";\r\nimport { subject } from \"@matechs/effect/lib/stream\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport * as O from \"fp-ts/lib/Option\";\r\n\r\nexport interface Store<A> {\r\n  next: (f: (current: A) => A) => T.Async<void>;\r\n  interrupt: T.Effect<unknown, unknown, never, void>;\r\n  subscribe: T.Sync<S.Stream<unknown, unknown, never, A>>;\r\n}\r\n\r\nexport const store = <A>(initial?: A) =>\r\n  pipe(\r\n    Q.unboundedQueue<A>(),\r\n    T.zip(ref.makeRef(initial ? [initial] : [])),\r\n    T.chain(([queue, state]) => {\r\n      const next = (f: (current: A) => A) =>\r\n        pipe(\r\n          state.update(([current]) => [f(current)]),\r\n          T.chain(([a]) => queue.offer(a))\r\n        );\r\n\r\n      return pipe(\r\n        subject(S.fromSource(M.pure(pipe(queue.take, T.map(O.some))))),        \r\n        T.map((s): Store<A> => ({ ...s, next }))\r\n      );\r\n    })\r\n  );\r\n","import { effect as T } from \"@matechs/effect\";\r\nimport * as E from \"fp-ts/lib/Either\";\r\nimport { flow } from \"fp-ts/lib/function\";\r\n\r\nexport const uri = \"@uri/fetch\";\r\n\r\nexport interface Fetch {\r\n  [uri]: {\r\n    fetch: typeof window.fetch;\r\n  }\r\n}\r\n\r\nexport const fetchLive: Fetch = {\r\n  [uri]: {\r\n    fetch: (...args) => new Promise(resolve => {\r\n      setTimeout(() => {\r\n        resolve(window.fetch.bind(window)(...args))\r\n      }, 2000)\r\n    })\r\n  },\r\n};\r\n\r\nexport const provideFetch = T.provide(fetchLive)\r\n\r\nclass FetchFailed extends Error {\r\n    constructor(info: string) {\r\n      super(`Unable to fetch: ${info}`);\r\n      this.name = \"FetchFailed\";\r\n    }\r\n  }\r\n\r\nconst makeFetchFailed = (url: string) => (error: string) => new FetchFailed(\r\n    `Fetching data from `\r\n)\r\n\r\nexport const fetch = (input: RequestInfo, init?: RequestInit) =>\r\n  T.accessM((_: Fetch) =>\r\n    T.async<FetchFailed, Response>((r) => {\r\n      try {\r\n        _[uri].fetch(input, init).then(response => response.json()).then(flow(E.right, r));\r\n      } catch (error) {\r\n        r(E.left(makeFetchFailed(typeof input === 'string' ? input : input.url)(error)));\r\n      }\r\n\r\n      return (cb) => {\r\n        cb(makeFetchFailed(typeof input === 'string' ? input : input.url)(\"\"));\r\n      };\r\n    })\r\n  );\r\n","import { effect as T, stream as S, managed as M } from \"@matechs/effect\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { log } from \"@matechs/console\";\r\n\r\nexport const uri = \"@uri/emitter\";\r\n\r\nexport type EventFor<TEventType extends string> = TEventType extends\r\n  | \"keypress\"\r\n  | \"keyup\"\r\n  | \"keydown\"\r\n  ? KeyboardEvent\r\n  : TEventType extends \"click\" | \"dblclick\" | \"mousemove\" | \"mousedown\" | \"mouseup\"\r\n  ? MouseEvent\r\n  : Event;\r\n\r\nexport type EventHandler<TEventType extends string> = (\r\n  evt: EventFor<TEventType>\r\n) => void;\r\n\r\nexport interface Emitter {\r\n  [uri]: {\r\n    fromEvent: <TEventType extends string>(\r\n      type: TEventType\r\n    ) => (cb: EventHandler<TEventType>) => T.Effect<unknown, unknown, never, void>;\r\n    addEventListener: <TElement extends Pick<Element, 'addEventListener' | 'removeEventListener'>>(\r\n      el: TElement\r\n    ) => <TEventType extends string>(\r\n      type: TEventType\r\n    ) => (cb: EventHandler<TEventType>) => T.Effect<unknown, unknown, never, void>;\r\n  };\r\n}\r\n\r\n// Events\r\nexport const subscribe = <TEventType extends string>(type: TEventType, ret?: any) => <\r\n  TElement extends  Pick<Element, 'addEventListener' | 'removeEventListener'>\r\n>(\r\n  el?: TElement\r\n) => {\r\n  return S.fromSource(\r\n    M.managed.chain(\r\n      M.bracket(\r\n        T.accessM((_: Emitter) =>\r\n          T.sync(() => {\r\n            const { next, ops, hasCB } = S.su.queueUtils<\r\n              never,\r\n              EventFor<TEventType>\r\n            >();\r\n\r\n            const fn = el ? _[uri].addEventListener(el) : _[uri].fromEvent;\r\n\r\n            return {\r\n              unsubscribe: fn(type)(a => {\r\n                next({ _tag: \"offer\", a })\r\n                return ret\r\n              }),\r\n              ops,\r\n              hasCB\r\n            };\r\n          })\r\n        ),\r\n        _ => _.unsubscribe\r\n      ),\r\n      ({ ops, hasCB }) => S.su.emitter(ops, hasCB)\r\n    )\r\n  );\r\n};\r\n\r\nexport const makeEmitterLive = <\r\n  TRoot extends Pick<Element, \"addEventListener\" | \"removeEventListener\">\r\n>(\r\n  rootEl: TRoot\r\n): Emitter => {\r\n  return {\r\n    [uri]: {\r\n      fromEvent: <TEventType extends string>(type: TEventType) => (\r\n        cb: EventHandler<TEventType>\r\n      ) => {\r\n        const wrappedCb = (e: EventFor<TEventType>) => {\r\n          e.stopPropagation();\r\n          return cb(e);\r\n        };\r\n        rootEl.addEventListener(type, wrappedCb as any);\r\n\r\n        return T.sync(() => rootEl.removeEventListener(type, cb as any));\r\n      },\r\n      addEventListener: <TElement extends Pick<Element, 'addEventListener' | 'removeEventListener'>>(el: TElement) => <\r\n        TEventType extends string\r\n      >(\r\n        type: TEventType\r\n      ) => (cb: EventHandler<TEventType>) => {\r\n        const wrappedCb = (e: EventFor<TEventType>) => {\r\n          e.stopPropagation();\r\n          return cb(e);\r\n        };\r\n        el.addEventListener(type, wrappedCb as any);\r\n\r\n        return T.sync(() => el.removeEventListener(type, cb as any));\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * waitForKeyPress :: number -> Effect NoEnv never void\r\n *\r\n * Given a keyCode returns an effect that resolves once the user\r\n * presses a key on the keyboard matching the key code.\r\n */\r\nexport const waitForKeyPress = (...keyCodes: number[]) =>\r\n  T.effect.chain(log(\"Waiting for \", ...keyCodes), () =>\r\n    pipe(\r\n      subscribe(\"keyup\")(),\r\n      S.filter(event => keyCodes.includes(event.keyCode)),\r\n      S.take(1),\r\n      S.collectArray,\r\n      T.map(([evt]) => evt)\r\n    )\r\n  );\r\n","import { effect as T } from \"@matechs/effect\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport {  flow } from \"fp-ts/lib/function\";\r\n\r\nexport const documentUri = \"@uri/document\";\r\n\r\nexport type DocumentEnv = { [documentUri]: Document };\r\n\r\nexport const documentLive = {\r\n  [documentUri]: document,\r\n};\r\n\r\nexport const provideDocument = T.provide(documentLive);\r\n\r\nexport const getDocument = T.accessM(\r\n  flow((_: DocumentEnv) => _[documentUri], T.pure)\r\n);\r\n\r\nexport const mapDocument = <R, E, A>(f: (doc: Document) => T.Effect<unknown, R, E, A>) =>\r\n  pipe(getDocument, T.map(f));\r\n","import { effect as T, stream as S } from \"@matechs/effect\";\r\n\r\nimport * as O from \"fp-ts/lib/Option\";\r\nimport * as A from \"fp-ts/lib/ReadonlyArray\";\r\nimport * as Eq from \"fp-ts/lib/Eq\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { constant, identity, flow, constVoid, tuple } from \"fp-ts/lib/function\";\r\n\r\nimport * as t from \"io-ts\";\r\nimport { Do } from \"fp-ts-contrib/lib/Do\";\r\n\r\nimport {\r\n  createElement,\r\n  querySelector,\r\n  makeElementNotFound,\r\n  $,\r\n  parentElement,\r\n  makeParentElementNotFound,\r\n  Dom,\r\n} from \"./dom\";\r\nimport * as Fetch from \"./fetch\";\r\nimport { subscribe } from \"./emitter\";\r\nimport { store, Store } from \"./store\";\r\nimport { log, Console } from \"@matechs/console\";\r\n\r\n/**\r\n * ```hs\r\n *\r\n * URL :: string\r\n *\r\n * ```\r\n *\r\n * API URL where a list of todo objects is requested from\r\n */\r\nconst URL = \"https://jsonplaceholder.typicode.com/todos\";\r\n\r\n/**\r\n * ```hs\r\n *\r\n * Todo :: t.TypeC<Todo>\r\n *\r\n * ```\r\n *\r\n * io-ts decoder for Todo\r\n */\r\nconst todoDecoder = t.type(\r\n  {\r\n    id: t.number,\r\n    userId: t.number,\r\n    title: t.string,\r\n    completed: t.boolean,\r\n  },\r\n  \"Todo\"\r\n);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * Todos :: t.TypeC<Todos>\r\n *\r\n * ```\r\n *\r\n * io-ts decoder for a list of [[Todo]]\r\n */\r\nconst todosDecoder = t.readonlyArray(todoDecoder);\r\n\r\n// Types\r\ntype Todo = t.TypeOf<typeof todoDecoder>;\r\n\r\ntype Todos = readonly Todo[];\r\n\r\nconst eqTodoById = Eq.contramap((todo: Todo) => todo.id)(Eq.eqNumber);\r\n\r\n// Store (environment)\r\nconst uri = \"@uri/todo-store\";\r\n\r\ninterface TodoStore {\r\n  [uri]: Store<Todos>;\r\n}\r\n\r\n/**\r\n * ```hs\r\n *\r\n * todosStore :: Effect unknown never (Store Todos)\r\n *\r\n * ```\r\n *\r\n * You can update the list of todos by passing a callback function to store.next\r\n * or subscribe to store changes using the store.subscribe stream.\r\n */\r\nconst storeT = store<Todos>();\r\n\r\nconst provideTodoStore = T.provideM(\r\n  pipe(\r\n    storeT,\r\n    T.map((store) => ({ [uri]: store }))\r\n  )\r\n);\r\n\r\nconst todoStore = pipe(T.access((_: TodoStore) => _[uri]));\r\n\r\n// APIS\r\nconst fetchTodos = pipe(\r\n  // Fetch list of todos from the server\r\n  Fetch.fetch(URL),\r\n  // Decode the response\r\n  T.chain((response) => T.sync(() => todosDecoder.decode(response))),\r\n  // From Effect<R, E, Either<E2, Todos> to Effect<R, E | E2, Todos>\r\n  T.chain(T.fromEither)\r\n);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * html :: string\r\n *\r\n * ```\r\n *\r\n * HTML used to create a todo for\r\n */\r\nconst html = `<li>\r\n    <div class=\"view\">\r\n        <input data-toggle class=\"toggle\" type=\"checkbox\">\r\n        <label data-edit></label>\r\n        <button data-remove class=\"destroy\"></button>\r\n    </div>\r\n    <input class=\"edit\" />\r\n</li>`;\r\n\r\n// TODO: Use environment to produce div\r\nconst _div = createElement(\"div\");\r\n\r\n/**\r\n * ```hs\r\n *\r\n * createDomNodeForTodo :: Effect\r\n *\r\n * ```\r\n *\r\n * Create a dom element for a todo\r\n */\r\nconst createDomNodeForTodo = pipe(\r\n  _div,\r\n  T.chain((el) =>\r\n    T.sync(() => {\r\n      el.innerHTML = html;\r\n      return querySelector(\"li\")(el);\r\n    })\r\n  ),\r\n  T.chain(\r\n    T.fromOption(\r\n      constant(\r\n        makeElementNotFound(\"Unable to create DOM element for todo item.\")\r\n      )\r\n    )\r\n  )\r\n);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * todosUl :: Effect\r\n *\r\n * ```\r\n *\r\n * Select the ul dom node that contains the list of li nodes that are todo items.\r\n */\r\nconst todosUl = $<HTMLUListElement>(\".todo-list\");\r\n\r\n/**\r\n * ```hs\r\n *\r\n * updateDomNodeOfTodo :: Todo -> HTMLLIElement -> Effect\r\n *\r\n * ```\r\n *\r\n * Update a given todo dom li node with information from a [[Todo]] model\r\n */\r\nconst updateDomNodeOfTodo = (todo: Todo) => (todoLi: HTMLLIElement) =>\r\n  pipe(\r\n    Do(O.option)\r\n      // Select the input and label dom nodes that are inside the li node\r\n      .bind(\"label\", querySelector(\"label\")(todoLi))\r\n      .bind(\"checkbox\", querySelector(\"input\")(todoLi))\r\n      .bind(\"input\", querySelector<HTMLInputElement>(\"input.edit\")(todoLi))\r\n      .return(({ label, checkbox, input }) =>\r\n        T.sync(() => {\r\n          // Update title\r\n          label.innerHTML = todo.title;\r\n\r\n          // Add todo id as attribute\r\n          todoLi.setAttribute(\"data-todo-id\", \"\" + todo.id);\r\n\r\n          // Mark as completed if so\r\n          todo.completed && todoLi.classList.add(\"completed\");\r\n          checkbox.checked = todo.completed;\r\n          input.value = todo.title;\r\n\r\n          return todoLi;\r\n        })\r\n      ),\r\n    // TODO: Handle if label or input aren't available\r\n    T.fromOption(constant(Error(\"\"))),\r\n    T.chain(identity)\r\n  );\r\n\r\nconst clickedTodoId = (target: HTMLElement) =>\r\n  pipe(\r\n    parentElement<HTMLElement, HTMLDivElement>(target),\r\n    O.chain((div) => parentElement<HTMLDivElement, HTMLLIElement>(div)),\r\n    T.pure,\r\n    T.chain(T.fromOption(constant(makeParentElementNotFound(target)))),\r\n    T.map((parent) =>\r\n      pipe(\r\n        parent.getAttribute(\"data-todo-id\"),\r\n        O.fromNullable,\r\n        O.map(Number),\r\n        O.map((todoId) => tuple(todoId, parent))\r\n      )\r\n    ),\r\n    T.chain(T.fromOption(constant(makeParentElementNotFound(target))))\r\n  );\r\n\r\n/**\r\n * ```hs\r\n *\r\n * handleEvents :: Effect\r\n *\r\n * ```\r\n *\r\n * Handle click events that indicate the user wants to:\r\n * - Remove the todo\r\n * - Toggle the todo's completed status\r\n * - Edit the todo's title\r\n *\r\n */\r\nconst handleEvents = pipe(\r\n  // With the root dom node that is the list of items\r\n  todosUl,\r\n  S.encaseEffect,\r\n  // Subscribe to clicking the list\r\n  S.chain(pipe(subscribe(\"click\"))),\r\n  // Map the mouse event to the target (currentTarget would be the list, we want what the user actually clicked.)\r\n  S.map((_) => _.target),\r\n  S.map(O.fromNullable),\r\n  S.chain(S.fromOption),\r\n  S.chain((_) => {\r\n    const target = _ as HTMLElement;\r\n\r\n    const todoIdEffect = clickedTodoId(target);\r\n\r\n    // Clicking the remove button (red x on hover)\r\n    if (target.hasAttribute(\"data-remove\")) {\r\n      return pipe(\r\n        todoIdEffect,\r\n        T.zip(todoStore),\r\n        T.chain(([[todoId], store]) =>\r\n          store.next((todos) => todos.filter((todo) => todo.id !== todoId))\r\n        ),\r\n        S.encaseEffect\r\n      );\r\n\r\n      // Clicking the toggle \"completed\" checkbox\r\n    } else if (target.hasAttribute(\"data-toggle\")) {\r\n      return pipe(\r\n        todoIdEffect,\r\n        T.zip(todoStore),\r\n        T.chain(([[todoId], store]) =>\r\n          store.next((todos) =>\r\n            todos.map((todo) =>\r\n              todo.id === todoId\r\n                ? { ...todo, completed: !todo.completed }\r\n                : todo\r\n            )\r\n          )\r\n        ),\r\n        S.encaseEffect\r\n      );\r\n\r\n      // Clicking the label to edit the title\r\n    } else if (target.hasAttribute(\"data-edit\")) {\r\n      return pipe(\r\n        todoIdEffect,\r\n        T.chain(([todoId, li]) => {\r\n          // Makes the text input box visible\r\n          const addClass = T.sync(() => {\r\n            li.classList.add(\"editing\");\r\n          });\r\n\r\n          // Hides the text input box\r\n          const removeClass = T.sync(() => {\r\n            li.classList.remove(\"editing\");\r\n          });\r\n\r\n          const input = pipe(\r\n            li,\r\n            querySelector<HTMLInputElement>(\"input.edit\"),\r\n            T.fromOption(constant(makeElementNotFound(\"li>input\"))),\r\n            T.chain((input) => {\r\n              // Gives the text input box focus and selects the text\r\n              const setFocus = T.sync(() => {\r\n                input.focus();\r\n                input.select();\r\n              });\r\n\r\n              // Executes when the text input box looses focus\r\n              // Will hide the text input box\r\n              const handleBlur = pipe(\r\n                input,\r\n                subscribe(\"blur\"),\r\n                S.take(1),\r\n                S.drain,\r\n                T.zip(removeClass)\r\n              );\r\n\r\n              // Updates the store on every keystroke\r\n              const handlTextInput = pipe(\r\n                input,\r\n                // Listen to the text input's \"oninput\" event\r\n                subscribe(\"input\"),\r\n                S.chain(\r\n                  constant(\r\n                    pipe(\r\n                      todoStore,\r\n                      // Update the title of the todo in the store\r\n                      T.chain((store) =>\r\n                        store.next((todos) =>\r\n                          todos.map((todo) =>\r\n                            todo.id === todoId\r\n                              ? { ...todo, title: input.value }\r\n                              : todo\r\n                          )\r\n                        )\r\n                      ),\r\n                      S.encaseEffect\r\n                    )\r\n                  )\r\n                ),\r\n                // Do this until the text input box looses focus\r\n                S.takeUntil(handleBlur),\r\n                S.drain\r\n              );\r\n\r\n              return pipe(setFocus, T.zip(handlTextInput));\r\n            })\r\n          );\r\n\r\n          return pipe(addClass, T.zip(input));\r\n        }),\r\n        S.encaseEffect\r\n      );\r\n    }\r\n\r\n    return S.encaseEffect(T.pure(constVoid()));\r\n  }),\r\n  S.drain\r\n);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * replaceTodosInStore :: [Todo] => Effect\r\n *\r\n * ```\r\n */\r\nconst replaceTodosInStore = (todos: Todos) =>\r\n  pipe(\r\n    todoStore,\r\n    T.chain((store) => store.next(constant(todos)))\r\n  );\r\n\r\n/**\r\n * ```hs\r\n *\r\n * fetchAndStoreTodos :: Effect\r\n *\r\n * ```\r\n *\r\n * Fetch todo items from the server and replace the store with them.\r\n */\r\nconst fetchAndStoreTodos = pipe(fetchTodos, T.chain(replaceTodosInStore));\r\n\r\nconst logChanges = T.Do()\r\n  .bind(\"store\", todoStore)\r\n  .bindL(\"subscription\", ({ store }) => store.subscribe)\r\n  .doL(({ subscription }) =>\r\n    pipe(subscription, S.chain(flow(log, S.encaseEffect)), S.drain)\r\n  )\r\n  .return(constVoid);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * emptyListOfTodos :: [Todo]\r\n *\r\n * ```\r\n *\r\n */\r\nconst emptyListOfTodos: Todos = [];\r\n\r\n/**\r\n * ```hs\r\n *\r\n * getTodosDifference :: [Todo] -> [Todo] -> [Todo]\r\n *\r\n * ```\r\n *\r\n * Return todos from list a that are not in list b.\r\n * This is used to remove dom nodes of deleted todos\r\n *\r\n */\r\nconst getTodosDifference = A.difference(eqTodoById);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * removeTodosFromDom :: [Todo] -> Effect\r\n *\r\n * ```\r\n *\r\n * For each todo, remove it's related dom node if present.\r\n *\r\n */\r\nconst removeTodosFromDom = (todos: Todos) =>\r\n  pipe(\r\n    todos,\r\n    A.map((todo) =>\r\n      pipe(\r\n        // Find the dom node\r\n        $<HTMLLIElement>(`[data-todo-id=\"${todo.id}\"]`),\r\n        // Remove it from the dom\r\n        T.chain((li) => T.sync(li.remove.bind(li)))\r\n      )\r\n    ),\r\n    A.readonlyArray.sequence(T.effect)\r\n  );\r\n\r\n/**\r\n * ```hs\r\n *\r\n * optionOfPreviousTodoInDom :: Effect (Option HTMLLIElement)\r\n *\r\n * ```\r\n *\r\n * Initial \"previous sibling\". Used as the initial value when reducing a list of todos\r\n * into a single effect updating the dom\r\n *\r\n */\r\nconst optionOfPreviousTodoInDom: T.Effect<\r\n  unknown,\r\n  Console & Dom,\r\n  ReturnType<typeof makeElementNotFound> | Error,\r\n  O.Option<HTMLLIElement>\r\n> = T.pure(O.none);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * createAndUpdateTodoNode :: HTMLUListElement -> Effect (Option HTMLLIElement) -> Effect HTMLLIElement\r\n *\r\n * ```\r\n *\r\n * Creates new dom nodes for todos that are not yet present in the dom\r\n * and updates dom nodes of other todos\r\n *\r\n */\r\nconst createAndUpdateTodoNode = (ul: HTMLUListElement) => (\r\n  domNodeOfPreviousTodoInList: O.Option<HTMLLIElement>\r\n) => (todo: Todo) =>\r\n  pipe(\r\n    // Create a dom node\r\n    createDomNodeForTodo,\r\n    // Update it with information from the todo\r\n    T.chain(updateDomNodeOfTodo(todo)),\r\n    // Get the dom node it should attach itself to if available\r\n    // With the new dom node and it's \"previous sibling\"\r\n    T.chainTap((li) =>\r\n      pipe(\r\n        domNodeOfPreviousTodoInList,\r\n        O.fold(\r\n          // Prepend the dom node to the start of the list if no previous sibling is available\r\n          constant(T.sync(() => ul.prepend(li))),\r\n          // Other wise attach it after it's sibling\r\n          (domNodeOfPreviousTodoInList) =>\r\n            T.sync(() => domNodeOfPreviousTodoInList.after(li))\r\n        )\r\n      )\r\n    )\r\n  );\r\n\r\n/**\r\n * ```hs\r\n *\r\n * updateDomWithTodos :: HTMLUListElement -> [Todo] -> Effect\r\n *\r\n * ```\r\n *\r\n * Creates new dom nodes for todos that are not yet present in the dom\r\n * and updates dom nodes of other todos\r\n *\r\n */\r\nconst updateDomWithTodos = (ul: HTMLUListElement) => (todos: Todos) =>\r\n  pipe(\r\n    todos,\r\n    // Reduce the list of todos into a single effect\r\n    A.reduce(optionOfPreviousTodoInDom, (acc, todo) =>\r\n      pipe(\r\n        // Chain over the previous effect\r\n        acc,\r\n        T.chain((optionOfSiblingTodoInDom) =>\r\n          pipe(\r\n            ul,\r\n            querySelector<HTMLLIElement>(`[data-todo-id=\"${todo.id}\"]`),\r\n            O.fold(\r\n              // Create a dom node for new todos\r\n              // The accumulated effect is passed so that\r\n              // new dom nodes can attach themselves after the previous one\r\n              constant(\r\n                createAndUpdateTodoNode(ul)(optionOfSiblingTodoInDom)(todo)\r\n              ),\r\n              // Or if a dom node was found, update it\r\n              updateDomNodeOfTodo(todo)\r\n            ),\r\n            T.map(O.some)\r\n          )\r\n        )\r\n      )\r\n    )\r\n  );\r\n\r\n/**\r\n * ```hs\r\n *\r\n * commitStoreUpdatesToDom :: Effect\r\n *\r\n * ```\r\n *\r\n * Subscribes to store changes and updates the dom.\r\n *\r\n */\r\nconst commitStoreUpdatesToDom = T.Do()\r\n  .bind(\"store\", todoStore)\r\n  .bindL(\"subscription\", ({ store }) => store.subscribe)\r\n  .bind(\"ul\", todosUl)\r\n  // With store subscription and root dom node do:\r\n  .doL(({ subscription, ul }) =>\r\n    pipe(\r\n      subscription,\r\n      // Take 10 todo items at a time\r\n      S.map(A.takeLeft(10)),\r\n      // Keep track of previous list to use for comparison\r\n      S.scan(tuple(emptyListOfTodos, emptyListOfTodos), ([prev], next) =>\r\n        tuple(next, prev)\r\n      ),\r\n      S.chain(([next, prev]) =>\r\n        S.encaseEffect(\r\n          pipe(\r\n            // Remove todos that were in the previous list but not in the next\r\n            removeTodosFromDom(getTodosDifference(prev, next)),\r\n            // Add todos to the dom that are in the new list but weren't in the previous\r\n            // or update nodes with new information\r\n            T.zip(updateDomWithTodos(ul)(next))\r\n          )\r\n        )\r\n      ),\r\n      S.drain\r\n    )\r\n  )\r\n  .return(constVoid);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * main :: Effect\r\n *\r\n * ```\r\n *\r\n * TodoMVC Program\r\n */\r\nexport const main = pipe(\r\n  T.parZip(\r\n    T.parZip(logChanges, T.parZip(fetchAndStoreTodos, handleEvents)),\r\n    commitStoreUpdatesToDom\r\n  ),\r\n\r\n  provideTodoStore\r\n);\r\n","import * as serviceWorker from \"./serviceWorker\";\nimport \"./index.scss\";\n\nimport { effect as T } from \"@matechs/effect\";\nimport { provideConsole } from \"@matechs/console\";\n\nimport { pipe } from \"fp-ts/lib/pipeable\";\n\nimport * as Todo from \"./modules/todo\";\nimport { provideDom } from \"./modules/dom\";\nimport { provideDocument } from \"./modules/document\";\nimport * as Fetch from \"./modules/fetch\";\n\nimport { makeEmitterLive } from \"./modules/emitter\";\n\n\nconst provided = pipe(\n    // Run the main todo program\n  Todo.main,\n  // Provide DOM utilities\n  provideDom,\n  // Provide document object\n  provideDocument,\n  // Provide window.fetch\n  Fetch.provideFetch,\n  // Provide logging capabilities\n  provideConsole,\n  // Provide event emitter with root element\n  T.provide(makeEmitterLive(document)),\n  // Provide depracated thing\n  // T.provide({\n  //   [T.AsyncRTURI]: {},\n  // }),\n);\n\nT.runToPromise(provided)\n  .then((foo) => console.log(\"Done\", foo))\n  .catch((error) => {\n    console.error(error);\n  });\n  \n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}