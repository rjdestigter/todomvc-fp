{"version":3,"sources":["serviceWorker.ts","modules/dom.ts","modules/store.ts","modules/fetch.ts","modules/emitter.ts","modules/document.ts","modules/utils.ts","modules/todo.ts","index.ts"],"names":["Boolean","window","location","hostname","match","eventType","initial","input","init","tagName","options","rootEl","uri","subscribe","type","ret","el","S","fromSource","M","managed","chain","bracket","T","accessM","_","sync","su","queueUtils","next","ops","hasCB","unsubscribe","addEventListener","fromEvent","fn","a","_tag","emitter","documentLive","document","provideDocument","provide","getDocument","flow","pure","domLive","createElement","provideDom","ElementNotFound","selectors","name","Error","ParentElementNotFound","child","makeElementNotFound","makeParentElementNotFound","raiseError","element","toString","querySelector","O","$","pipe","map","fromOption","constant","parentElement","node","EmptyOptionOfElement","message","fetchLive","fetch","args","Promise","resolve","setTimeout","bind","provideFetch","FetchFailed","info","makeFetchFailed","url","error","memoize","f","previousB","previousA","undefined","todoDecoder","t","id","userId","title","completed","todosDecoder","eqTodoById","Eq","todo","getFilteredTodos","filterBy","todos","A","takeTenTodos","storeT","Q","unboundedQueue","zip","ref","makeRef","queue","state","update","current","offer","get","head","subject","take","s","provideTodoStore","provideM","store","todoStore","access","fetchTodos","async","r","then","response","json","E","cb","decode","fromEither","_div","createDomNodeForTodo","innerHTML","todosUl","updateDomNodeOfTodo","todoLi","Do","return","label","checkbox","setAttribute","classList","add","remove","checked","value","identity","handleEvents","encaseEffect","target","todoIdEffect","div","parent","getAttribute","Number","todoId","tuple","clickedTodoId","hasAttribute","filter","li","addClass","removeClass","setFocus","focus","select","handleBlur","drain","handlTextInput","takeUntil","constVoid","fetchAndStoreTodos","logChanges","bindL","doL","subscription","log","emptyListOfTodos","getTodosDifference","optionOfPreviousTodoInDom","updateDomWithTodos","ul","acc","optionOfSiblingTodoInDom","domNodeOfPreviousTodoInList","chainTap","prepend","after","createAndUpdateTodoNode","commitStoreUpdatesToDom","scan","prev","sequence","effect","updateCounter","length","itemsLeft","makeHandleFilter","parSequenceT","links","forEach","link","handleClearCompleted","handleNewTodos","event","key","currentTarget","trim","Math","random","allTodosAreCompleted","constTrue","rest","handleMarkAllAsCompleted","susbscription","stateS","allCompleted","clickS","stateO","todosListed","listedTodo","mergeAll","main","provided","Todo","Fetch","provideConsole","e","stopPropagation","removeEventListener","runToPromise","foo","console","catch","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.2907f088.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL || '',\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import { effect as T, stream as S } from \"@matechs/effect\";\r\nimport * as O from \"fp-ts/lib/Option\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { constant, flow, identity } from \"fp-ts/lib/function\";\r\nimport { subscribe, Emitter, EventFor } from \"./emitter\";\r\nimport { DocumentEnv, getDocument } from \"./document\";\r\n\r\n/**\r\n * Environment\r\n */\r\nexport const uri = \"@uri/dom\";\r\n\r\nexport interface Dom {\r\n  [uri]: {\r\n    createElement<K extends keyof HTMLElementTagNameMap>(\r\n      tagName: K,\r\n      options?: ElementCreationOptions\r\n    ): HTMLElementTagNameMap[K];\r\n    createElement(\r\n      tagName: string,\r\n      options?: ElementCreationOptions\r\n    ): HTMLElement;\r\n  };\r\n}\r\n\r\nexport const domLive: Dom = {\r\n  [uri]: {\r\n    createElement: (tagName: any, options?: ElementCreationOptions) =>\r\n      document.createElement(tagName, options),\r\n  },\r\n};\r\n\r\nexport const provideDom = T.provide(domLive);\r\n\r\n/**\r\n * Errors\r\n */\r\nclass ElementNotFound extends Error {\r\n  constructor(selectors: string) {\r\n    super(`$(${selectors}) did not return an element.`);\r\n    this.name = \"ElementNotFound\";\r\n  }\r\n}\r\n\r\nclass ParentElementNotFound extends Error {\r\n  constructor(child: string) {\r\n    super(`Parent of node: ${child} not found.`);\r\n    this.name = \"ParentElementNotFound\";\r\n  }\r\n}\r\n\r\nexport const makeElementNotFound = (selectors: string) =>\r\n  new ElementNotFound(selectors);\r\n\r\nexport const raiseElementNotFound = flow(makeElementNotFound, T.raiseError);\r\n\r\nexport const makeParentElementNotFound = (element: HTMLElement) =>\r\n  new ParentElementNotFound(element.toString());\r\n\r\nexport const raiseParentElementNotFound = flow(\r\n  makeParentElementNotFound,\r\n  T.raiseError\r\n);\r\n\r\n/**\r\n * Utilities\r\n */\r\ninterface CreateElement {\r\n  <K extends keyof HTMLElementTagNameMap>(\r\n    tagName: K,\r\n    options?: ElementCreationOptions\r\n  ): T.Effect<unknown, Dom, never, HTMLElementTagNameMap[K]>;\r\n  (tagName: string, options?: ElementCreationOptions): T.Effect<\r\n    unknown,\r\n    Dom,\r\n    never,\r\n    HTMLElement\r\n  >;\r\n}\r\n\r\nexport const createElement: CreateElement = (\r\n  tagName: string,\r\n  options?: ElementCreationOptions\r\n) => T.accessM((_: Dom) => T.pure(_[uri].createElement(tagName, options)));\r\n\r\n/**\r\n * QuerySelector\r\n */\r\ninterface QuerySelector {\r\n  <K extends keyof HTMLElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: TNode\r\n  ) => O.Option<HTMLElementTagNameMap[K]>;\r\n  <K extends keyof SVGElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: TNode\r\n  ) => O.Option<SVGElementTagNameMap[K]>;\r\n  <E extends Element = Element>(selectors: string): <TNode extends ParentNode>(\r\n    node: TNode\r\n  ) => O.Option<E>;\r\n}\r\n\r\ninterface QuerySelectorT {\r\n  <K extends keyof HTMLElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: O.Option<TNode>\r\n  ) => O.Option<HTMLElementTagNameMap[K]>;\r\n  <K extends keyof SVGElementTagNameMap>(selectors: K): <\r\n    TNode extends ParentNode\r\n  >(\r\n    node: O.Option<TNode>\r\n  ) => O.Option<SVGElementTagNameMap[K]>;\r\n  <E extends Element = Element>(selectors: string): <TNode extends ParentNode>(\r\n    node: O.Option<TNode>\r\n  ) => O.Option<E>;\r\n}\r\n\r\nexport const querySelector: QuerySelector = (selectors: string) => <\r\n  TNode extends ParentNode\r\n>(\r\n  el: TNode\r\n) => O.fromNullable(el.querySelector(selectors));\r\n\r\nexport const querySelectorO: QuerySelectorT = (selectors: string) => <\r\n  TNode extends ParentNode\r\n>(\r\n  nodeOT: O.Option<TNode>\r\n) =>\r\n  pipe(\r\n    nodeOT,\r\n    O.map((el) => querySelector(selectors)(el))\r\n  );\r\n\r\n/**\r\n * $\r\n */\r\ninterface $ {\r\n  <K extends keyof HTMLElementTagNameMap>(selectors: K): T.Effect<\r\n    unknown,\r\n    DocumentEnv,\r\n    ElementNotFound,\r\n    HTMLElementTagNameMap[K]\r\n  >;\r\n  <K extends keyof SVGElementTagNameMap>(selectors: K): T.Effect<\r\n    unknown,\r\n    DocumentEnv,\r\n    ElementNotFound,\r\n    SVGElementTagNameMap[K]\r\n  >;\r\n  <E extends Element = Element>(selectors: string): T.Effect<\r\n    unknown,\r\n    DocumentEnv,\r\n    ElementNotFound,\r\n    E\r\n  >;\r\n}\r\n\r\nexport const $: $ = (selectors: string) =>\r\n  pipe(\r\n    getDocument,\r\n    T.map(querySelector(selectors)),\r\n    T.chain(T.fromOption(constant(makeElementNotFound(selectors))))\r\n  );\r\n\r\n/**\r\n * ```hs\r\n * parentElement :: Node -> Option<HTMLelement>\r\n * ```\r\n */\r\nexport const parentElement = <TNode extends Node, TParentNode extends Node>(\r\n  node: TNode\r\n) => O.fromNullable(node.parentElement as TParentNode | null);\r\n\r\nexport class EmptyOptionOfElement extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = \"EmptyOptionOfElement\";\r\n  }\r\n}\r\n\r\nexport const raiseEmptyOptionOfElement = (message: string) =>\r\n  T.raiseError(new EmptyOptionOfElement(message));\r\n\r\nexport const makeEventStream = <TEventType extends string>(\r\n  eventType: TEventType\r\n) => <\r\n  R,\r\n  E,\r\n  A extends Pick<Element, \"addEventListener\" | \"removeEventListener\">\r\n>(\r\n  elementT: T.Effect<unknown, R, E, O.Option<A>>\r\n) =>\r\n  pipe(\r\n    elementT,\r\n    T.map((elementO) =>\r\n      pipe(\r\n        elementO,\r\n        O.map(subscribe(eventType)),\r\n        (effect) => effect,\r\n        O.fold<\r\n          S.Stream<unknown, Emitter, never, EventFor<TEventType>>,\r\n          S.Stream<unknown, Emitter, EmptyOptionOfElement, EventFor<TEventType>>\r\n        >(\r\n          constant(\r\n            S.raised(\r\n              new EmptyOptionOfElement(\r\n                `Option does not contain some element to create ${eventType} event stream for`\r\n              )\r\n            )\r\n          ),\r\n          identity\r\n        )\r\n      )\r\n    )\r\n  );\r\n\r\nexport const makeClickStream = makeEventStream(\"click\");\r\n","import {\r\n  effect as T,\r\n  ref,\r\n  stream as S,\r\n  queue as Q,\r\n  managed as M,\r\n} from \"@matechs/effect\";\r\nimport { subject } from \"@matechs/effect/lib/stream\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport * as O from \"fp-ts/lib/Option\";\r\nimport { head } from \"fp-ts/lib/ReadonlyArray\";\r\n\r\nexport interface Store<A> {\r\n  next: (f: (current: A) => A) => T.Async<void>;\r\n  get: T.Sync<O.Option<A>>;\r\n  interrupt: T.Effect<unknown, unknown, never, void>;\r\n  subscribe: T.Sync<S.Stream<unknown, unknown, never, A>>;\r\n}\r\n\r\nexport const store = <A>(initial?: A) =>\r\n  pipe(\r\n    Q.unboundedQueue<A>(),\r\n    T.zip(ref.makeRef(initial ? [initial] : [])),\r\n    T.chain(([queue, state]) => {\r\n      const next = (f: (current: A) => A) =>\r\n        pipe(\r\n          state.update(([current]) => [f(current)]),\r\n          T.chain(([a]) => queue.offer(a))\r\n        );\r\n\r\n      const get = pipe(state.get, T.map(head));\r\n\r\n      return pipe(\r\n        subject(S.fromSource(M.pure(pipe(queue.take, T.map(O.some))))),\r\n        T.map((s): Store<A> => ({ ...s, get, next }))\r\n      );\r\n    })\r\n  );\r\n","import { effect as T } from \"@matechs/effect\";\r\nimport * as E from \"fp-ts/lib/Either\";\r\nimport { flow } from \"fp-ts/lib/function\";\r\n\r\nexport const uri = \"@uri/fetch\";\r\n\r\nexport interface Fetch {\r\n  [uri]: {\r\n    fetch: typeof window.fetch;\r\n  }\r\n}\r\n\r\nexport const fetchLive: Fetch = {\r\n  [uri]: {\r\n    fetch: (...args) => new Promise(resolve => {\r\n      setTimeout(() => {\r\n        resolve(window.fetch.bind(window)(...args))\r\n      }, 2000)\r\n    })\r\n  },\r\n};\r\n\r\nexport const provideFetch = T.provide(fetchLive)\r\n\r\nclass FetchFailed extends Error {\r\n    constructor(info: string) {\r\n      super(`Unable to fetch: ${info}`);\r\n      this.name = \"FetchFailed\";\r\n    }\r\n  }\r\n\r\nconst makeFetchFailed = (url: string) => (error: string) => new FetchFailed(\r\n    `Fetching data from `\r\n)\r\n\r\nexport const fetch = (input: RequestInfo, init?: RequestInit) =>\r\n  T.accessM((_: Fetch) =>\r\n    T.async<FetchFailed, Response>((r) => {\r\n      try {\r\n        _[uri].fetch(input, init).then(response => response.json()).then(flow(E.right, r));\r\n      } catch (error) {\r\n        r(E.left(makeFetchFailed(typeof input === 'string' ? input : input.url)(error)));\r\n      }\r\n\r\n      return (cb) => {\r\n        cb(makeFetchFailed(typeof input === 'string' ? input : input.url)(\"\"));\r\n      };\r\n    })\r\n  );\r\n","import { effect as T, stream as S, managed as M } from \"@matechs/effect\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { log } from \"@matechs/console\";\r\n\r\nexport const uri = \"@uri/emitter\";\r\n\r\nexport type EventFor<TEventType extends string> = TEventType extends\r\n  | \"keypress\"\r\n  | \"keyup\"\r\n  | \"keydown\"\r\n  ? KeyboardEvent\r\n  : TEventType extends \"click\" | \"dblclick\" | \"mousemove\" | \"mousedown\" | \"mouseup\"\r\n  ? MouseEvent\r\n  : Event;\r\n\r\nexport type EventHandler<TEventType extends string> = (\r\n  evt: EventFor<TEventType>\r\n) => void;\r\n\r\nexport interface Emitter {\r\n  [uri]: {\r\n    fromEvent: <TEventType extends string>(\r\n      type: TEventType\r\n    ) => (cb: EventHandler<TEventType>) => T.Effect<unknown, unknown, never, void>;\r\n    addEventListener: <TElement extends Pick<Element, 'addEventListener' | 'removeEventListener'>>(\r\n      el: TElement\r\n    ) => <TEventType extends string>(\r\n      type: TEventType\r\n    ) => (cb: EventHandler<TEventType>) => T.Effect<unknown, unknown, never, void>;\r\n  };\r\n}\r\n\r\n// Events\r\nexport const subscribe = <TEventType extends string>(type: TEventType, ret?: any) => <\r\n  TElement extends  Pick<Element, 'addEventListener' | 'removeEventListener'>\r\n>(\r\n  el?: TElement\r\n) => {\r\n  return S.fromSource(\r\n    M.managed.chain(\r\n      M.bracket(\r\n        T.accessM((_: Emitter) =>\r\n          T.sync(() => {\r\n            const { next, ops, hasCB } = S.su.queueUtils<\r\n              never,\r\n              EventFor<TEventType>\r\n            >();\r\n\r\n            const fn = el ? _[uri].addEventListener(el) : _[uri].fromEvent;\r\n\r\n            return {\r\n              unsubscribe: fn(type)(a => {\r\n                next({ _tag: \"offer\", a })\r\n                return ret\r\n              }),\r\n              ops,\r\n              hasCB\r\n            };\r\n          })\r\n        ),\r\n        _ => _.unsubscribe\r\n      ),\r\n      ({ ops, hasCB }) => S.su.emitter(ops, hasCB)\r\n    )\r\n  );\r\n};\r\n\r\nexport const makeEmitterLive = <\r\n  TRoot extends Pick<Element, \"addEventListener\" | \"removeEventListener\">\r\n>(\r\n  rootEl: TRoot\r\n): Emitter => {\r\n  return {\r\n    [uri]: {\r\n      fromEvent: <TEventType extends string>(type: TEventType) => (\r\n        cb: EventHandler<TEventType>\r\n      ) => {\r\n        const wrappedCb = (e: EventFor<TEventType>) => {\r\n          e.stopPropagation();\r\n          return cb(e);\r\n        };\r\n        rootEl.addEventListener(type, wrappedCb as any);\r\n\r\n        return T.sync(() => rootEl.removeEventListener(type, cb as any));\r\n      },\r\n      addEventListener: <TElement extends Pick<Element, 'addEventListener' | 'removeEventListener'>>(el: TElement) => <\r\n        TEventType extends string\r\n      >(\r\n        type: TEventType\r\n      ) => (cb: EventHandler<TEventType>) => {\r\n        const wrappedCb = (e: EventFor<TEventType>) => {\r\n          e.stopPropagation();\r\n          return cb(e);\r\n        };\r\n        el.addEventListener(type, wrappedCb as any);\r\n\r\n        return T.sync(() => el.removeEventListener(type, cb as any));\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * waitForKeyPress :: number -> Effect NoEnv never void\r\n *\r\n * Given a keyCode returns an effect that resolves once the user\r\n * presses a key on the keyboard matching the key code.\r\n */\r\nexport const waitForKeyPress = (...keyCodes: number[]) =>\r\n  T.effect.chain(log(\"Waiting for \", ...keyCodes), () =>\r\n    pipe(\r\n      subscribe(\"keyup\")(),\r\n      S.filter(event => keyCodes.includes(event.keyCode)),\r\n      S.take(1),\r\n      S.collectArray,\r\n      T.map(([evt]) => evt)\r\n    )\r\n  );\r\n","import { effect as T } from \"@matechs/effect\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport {  flow } from \"fp-ts/lib/function\";\r\n\r\nexport const documentUri = \"@uri/document\";\r\n\r\nexport type DocumentEnv = { [documentUri]: Document };\r\n\r\nexport const documentLive = {\r\n  [documentUri]: document,\r\n};\r\n\r\nexport const provideDocument = T.provide(documentLive);\r\n\r\nexport const getDocument = T.accessM(\r\n  flow((_: DocumentEnv) => _[documentUri], T.pure)\r\n);\r\n\r\nexport const mapDocument = <R, E, A>(f: (doc: Document) => T.Effect<unknown, R, E, A>) =>\r\n  pipe(getDocument, T.map(f));\r\n","export const memoize = <A, B>(f: (arg: A) => B) => {\r\n    let previousA: A | undefined = undefined;\r\n    let previousB: B;\r\n\r\n    return (a: A) => {\r\n        if (previousA == null)\r\n            previousA = a;\r\n\r\n        if(a !== previousA || previousB == null) {\r\n            previousA = a\r\n            previousB = f(previousA)\r\n        }\r\n\r\n        return previousB \r\n    }\r\n}","import { effect as T, stream as S } from \"@matechs/effect\";\r\n\r\nimport * as O from \"fp-ts/lib/Option\";\r\nimport * as A from \"fp-ts/lib/ReadonlyArray\";\r\nimport * as Eq from \"fp-ts/lib/Eq\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport {\r\n  constant,\r\n  identity,\r\n  flow,\r\n  constVoid,\r\n  tuple,\r\n  constTrue,\r\n} from \"fp-ts/lib/function\";\r\n\r\nimport * as t from \"io-ts\";\r\nimport { Do } from \"fp-ts-contrib/lib/Do\";\r\n\r\nimport {\r\n  createElement,\r\n  querySelector,\r\n  makeElementNotFound,\r\n  $,\r\n  parentElement,\r\n  makeParentElementNotFound,\r\n  Dom,\r\n} from \"./dom\";\r\nimport * as Fetch from \"./fetch\";\r\nimport { subscribe, Emitter } from \"./emitter\";\r\nimport { store, Store } from \"./store\";\r\nimport { log, Console } from \"@matechs/console\";\r\nimport { memoize } from \"./utils\";\r\n\r\n/**\r\n * ```hs\r\n *\r\n * URL :: string\r\n *\r\n * ```\r\n *\r\n * API URL where a list of todo objects is requested from\r\n */\r\nconst URL = \"https://jsonplaceholder.typicode.com/todos\";\r\n\r\n/**\r\n * ```hs\r\n *\r\n * Todo :: t.TypeC<Todo>\r\n *\r\n * ```\r\n *\r\n * io-ts decoder for Todo\r\n */\r\nconst todoDecoder = t.type(\r\n  {\r\n    id: t.number,\r\n    userId: t.number,\r\n    title: t.string,\r\n    completed: t.boolean,\r\n  },\r\n  \"Todo\"\r\n);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * Todos :: t.TypeC<Todos>\r\n *\r\n * ```\r\n *\r\n * io-ts decoder for a list of [[Todo]]\r\n */\r\nconst todosDecoder = t.readonlyArray(todoDecoder);\r\n\r\n// Types\r\ntype Todo = t.TypeOf<typeof todoDecoder>;\r\n\r\ntype Todos = readonly Todo[];\r\n\r\nconst eqTodoById = Eq.contramap((todo: Todo) => todo.id)(Eq.eqNumber);\r\n\r\n// Store (environment)\r\nconst uri = \"@uri/todo-store\";\r\n\r\ninterface TodosState {\r\n  todos: Todos;\r\n  filterBy: \"all\" | \"active\" | \"completed\";\r\n}\r\n\r\ntype TodosStore = Store<TodosState>;\r\n\r\ninterface TodoStoreEnv {\r\n  [uri]: TodosStore;\r\n}\r\n\r\n// Functions\r\nconst getFilteredTodos = memoize((filterBy: TodosState[\"filterBy\"]) =>\r\n  memoize((todos: Todos) =>\r\n    filterBy === \"all\"\r\n      ? todos\r\n      : pipe(\r\n          todos,\r\n          A.filter((todo) =>\r\n            filterBy === \"completed\" ? todo.completed : !todo.completed\r\n          )\r\n        )\r\n  )\r\n);\r\n\r\nconst takeTenTodos = memoize<Todos, Todos>(A.takeLeft(10))\r\n\r\n/**\r\n * ```hs\r\n *\r\n * todosStore :: Effect unknown never (Store Todos)\r\n *\r\n * ```\r\n *\r\n * You can update the list of todos by passing a callback function to store.next\r\n * or subscribe to store changes using the store.subscribe stream.\r\n */\r\nconst storeT = store<TodosState>({\r\n  todos: [],\r\n  filterBy: \"all\",\r\n});\r\n\r\nconst provideTodoStore = T.provideM(\r\n  pipe(\r\n    storeT,\r\n    T.map((store) => ({ [uri]: store }))\r\n  )\r\n);\r\n\r\nconst todoStore = pipe(T.access((_: TodoStoreEnv) => _[uri]));\r\n\r\n// APIS\r\nconst fetchTodos = pipe(\r\n  // Fetch list of todos from the server\r\n  Fetch.fetch(URL),\r\n  // Decode the response\r\n  T.chain((response) => T.sync(() => todosDecoder.decode(response))),\r\n  // From Effect<R, E, Either<E2, Todos> to Effect<R, E | E2, Todos>\r\n  T.chain(T.fromEither)\r\n);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * html :: string\r\n *\r\n * ```\r\n *\r\n * HTML used to create a todo for\r\n */\r\nconst html = `<li>\r\n    <div class=\"view\">\r\n        <input data-toggle class=\"toggle\" type=\"checkbox\">\r\n        <label data-edit></label>\r\n        <button data-remove class=\"destroy\"></button>\r\n    </div>\r\n    <input class=\"edit\" />\r\n</li>`;\r\n\r\n// TODO: Use environment to produce div\r\nconst _div = createElement(\"div\");\r\n\r\n/**\r\n * ```hs\r\n *\r\n * createDomNodeForTodo :: Effect\r\n *\r\n * ```\r\n *\r\n * Create a dom element for a todo\r\n */\r\nconst createDomNodeForTodo = pipe(\r\n  _div,\r\n  T.chain((el) =>\r\n    T.sync(() => {\r\n      el.innerHTML = html;\r\n      return querySelector(\"li\")(el);\r\n    })\r\n  ),\r\n  T.chain(\r\n    T.fromOption(\r\n      constant(\r\n        makeElementNotFound(\"Unable to create DOM element for todo item.\")\r\n      )\r\n    )\r\n  )\r\n);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * todosUl :: Effect\r\n *\r\n * ```\r\n *\r\n * Select the ul dom node that contains the list of li nodes that are todo items.\r\n */\r\nconst todosUl = $<HTMLUListElement>(\".todo-list\");\r\n\r\n/**\r\n * ```hs\r\n *\r\n * updateDomNodeOfTodo :: Todo -> HTMLLIElement -> Effect\r\n *\r\n * ```\r\n *\r\n * Update a given todo dom li node with information from a [[Todo]] model\r\n */\r\nconst updateDomNodeOfTodo = (todo: Todo) => (todoLi: HTMLLIElement) =>\r\n  pipe(\r\n    Do(O.option)\r\n      // Select the input and label dom nodes that are inside the li node\r\n      .bind(\"label\", querySelector(\"label\")(todoLi))\r\n      .bind(\"checkbox\", querySelector(\"input\")(todoLi))\r\n      .bind(\"input\", querySelector<HTMLInputElement>(\"input.edit\")(todoLi))\r\n      .return(({ label, checkbox, input }) =>\r\n        T.sync(() => {\r\n          // Update title\r\n          label.innerHTML = todo.title;\r\n\r\n          // Add todo id as attribute\r\n          todoLi.setAttribute(\"data-todo-id\", \"\" + todo.id);\r\n\r\n          // Mark as completed if so\r\n          todo.completed\r\n            ? todoLi.classList.add(\"completed\")\r\n            : todoLi.classList.remove(\"completed\");\r\n          checkbox.checked = todo.completed;\r\n          input.value = todo.title;\r\n\r\n          return todoLi;\r\n        })\r\n      ),\r\n    // TODO: Handle if label or input aren't available\r\n    T.fromOption(constant(Error(\"\"))),\r\n    T.chain(identity)\r\n  );\r\n\r\nconst clickedTodoId = (target: HTMLElement) =>\r\n  pipe(\r\n    parentElement<HTMLElement, HTMLDivElement>(target),\r\n    O.chain((div) => parentElement<HTMLDivElement, HTMLLIElement>(div)),\r\n    T.pure,\r\n    T.chain(T.fromOption(constant(makeParentElementNotFound(target)))),\r\n    T.map((parent) =>\r\n      pipe(\r\n        parent.getAttribute(\"data-todo-id\"),\r\n        O.fromNullable,\r\n        O.map(Number),\r\n        O.map((todoId) => tuple(todoId, parent))\r\n      )\r\n    ),\r\n    T.chain(T.fromOption(constant(makeParentElementNotFound(target))))\r\n  );\r\n\r\n/**\r\n * ```hs\r\n *\r\n * handleEvents :: Effect\r\n *\r\n * ```\r\n *\r\n * Handle click events that indicate the user wants to:\r\n * - Remove the todo\r\n * - Toggle the todo's completed status\r\n * - Edit the todo's title\r\n *\r\n */\r\nconst handleEvents = pipe(\r\n  // With the root dom node that is the list of items\r\n  todosUl,\r\n  S.encaseEffect,\r\n  // Subscribe to clicking the list\r\n  S.chain(pipe(subscribe(\"click\"))),\r\n  // Map the mouse event to the target (currentTarget would be the list, we want what the user actually clicked.)\r\n  S.map((_) => _.target),\r\n  S.map(O.fromNullable),\r\n  S.chain(S.fromOption),\r\n  S.chain((_) => {\r\n    const target = _ as HTMLElement;\r\n\r\n    const todoIdEffect = clickedTodoId(target);\r\n\r\n    // Clicking the remove button (red x on hover)\r\n    if (target.hasAttribute(\"data-remove\")) {\r\n      return pipe(\r\n        todoIdEffect,\r\n        T.zip(todoStore),\r\n        T.chain(([[todoId], store]) =>\r\n          store.next((state) => {\r\n            return {\r\n              ...state,\r\n              todos: state.todos.filter((todo) => todo.id !== todoId),\r\n            };\r\n          })\r\n        ),\r\n        S.encaseEffect\r\n      );\r\n\r\n      // Clicking the toggle \"completed\" checkbox\r\n    } else if (target.hasAttribute(\"data-toggle\")) {\r\n      return pipe(\r\n        todoIdEffect,\r\n        T.zip(todoStore),\r\n        T.chain(([[todoId], store]) =>\r\n          store.next((state) => {\r\n            return {\r\n              ...state,\r\n              todos: state.todos.map((todo) =>\r\n                todo.id === todoId\r\n                  ? { ...todo, completed: !todo.completed }\r\n                  : todo\r\n              ),\r\n            };\r\n          })\r\n        ),\r\n        S.encaseEffect\r\n      );\r\n\r\n      // Clicking the label to edit the title\r\n    } else if (target.hasAttribute(\"data-edit\")) {\r\n      return pipe(\r\n        todoIdEffect,\r\n        T.chain(([todoId, li]) => {\r\n          // Makes the text input box visible\r\n          const addClass = T.sync(() => {\r\n            li.classList.add(\"editing\");\r\n          });\r\n\r\n          // Hides the text input box\r\n          const removeClass = T.sync(() => {\r\n            li.classList.remove(\"editing\");\r\n          });\r\n\r\n          const input = pipe(\r\n            li,\r\n            querySelector<HTMLInputElement>(\"input.edit\"),\r\n            T.fromOption(constant(makeElementNotFound(\"li>input\"))),\r\n            T.chain((input) => {\r\n              // Gives the text input box focus and selects the text\r\n              const setFocus = T.sync(() => {\r\n                input.focus();\r\n                input.select();\r\n              });\r\n\r\n              // Executes when the text input box looses focus\r\n              // Will hide the text input box\r\n              const handleBlur = pipe(\r\n                input,\r\n                subscribe(\"blur\"),\r\n                S.take(1),\r\n                S.drain,\r\n                T.zip(removeClass)\r\n              );\r\n\r\n              // Updates the store on every keystroke\r\n              const handlTextInput = pipe(\r\n                input,\r\n                // Listen to the text input's \"oninput\" event\r\n                subscribe(\"input\"),\r\n                S.chain(\r\n                  constant(\r\n                    pipe(\r\n                      todoStore,\r\n                      // Update the title of the todo in the store\r\n                      T.chain((store) =>\r\n                        store.next((state) => ({\r\n                          ...state,\r\n                          todos: state.todos.map((todo) =>\r\n                            todo.id === todoId\r\n                              ? { ...todo, title: input.value }\r\n                              : todo\r\n                          ),\r\n                        }))\r\n                      ),\r\n                      S.encaseEffect\r\n                    )\r\n                  )\r\n                ),\r\n                // Do this until the text input box looses focus\r\n                S.takeUntil(handleBlur),\r\n                S.drain\r\n              );\r\n\r\n              return pipe(setFocus, T.zip(handlTextInput));\r\n            })\r\n          );\r\n\r\n          return pipe(addClass, T.zip(input));\r\n        }),\r\n        S.encaseEffect\r\n      );\r\n    }\r\n\r\n    return S.encaseEffect(T.pure(constVoid()));\r\n  }),\r\n  S.drain\r\n);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * replaceTodosInStore :: [Todo] => Effect\r\n *\r\n * ```\r\n */\r\nconst replaceTodosInStore = (todos: Todos) =>\r\n  pipe(\r\n    todoStore,\r\n    T.chain((store) => store.next((state) => ({ ...state, todos })))\r\n  );\r\n\r\n/**\r\n * ```hs\r\n *\r\n * fetchAndStoreTodos :: Effect\r\n *\r\n * ```\r\n *\r\n * Fetch todo items from the server and replace the store with them.\r\n */\r\nconst fetchAndStoreTodos = pipe(fetchTodos, T.chain(replaceTodosInStore));\r\n\r\nconst logChanges = T.Do()\r\n  .bind(\"store\", todoStore)\r\n  .bindL(\"subscription\", ({ store }) => store.subscribe)\r\n  .doL(({ subscription }) =>\r\n    pipe(subscription, S.chain(flow(log, S.encaseEffect)), S.drain)\r\n  )\r\n  .return(constVoid);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * emptyListOfTodos :: [Todo]\r\n *\r\n * ```\r\n *\r\n */\r\nconst emptyListOfTodos: Todos = [];\r\n\r\n/**\r\n * ```hs\r\n *\r\n * getTodosDifference :: [Todo] -> [Todo] -> [Todo]\r\n *\r\n * ```\r\n *\r\n * Return todos from list a that are not in list b.\r\n * This is used to remove dom nodes of deleted todos\r\n *\r\n */\r\nconst getTodosDifference = A.difference(eqTodoById);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * removeTodosFromDom :: [Todo] -> Effect\r\n *\r\n * ```\r\n *\r\n * For each todo, remove it's related dom node if present.\r\n *\r\n */\r\nconst removeTodosFromDom = (todos: Todos) =>\r\n  pipe(\r\n    todos,\r\n    A.map((todo) =>\r\n      pipe(\r\n        // Find the dom node\r\n        $<HTMLLIElement>(`[data-todo-id=\"${todo.id}\"]`),\r\n        // Remove it from the dom\r\n        T.chain((li) => T.sync(li.remove.bind(li)))\r\n      )\r\n    ),\r\n    A.readonlyArray.sequence(T.effect)\r\n  );\r\n\r\n/**\r\n * ```hs\r\n *\r\n * optionOfPreviousTodoInDom :: Effect (Option HTMLLIElement)\r\n *\r\n * ```\r\n *\r\n * Initial \"previous sibling\". Used as the initial value when reducing a list of todos\r\n * into a single effect updating the dom\r\n *\r\n */\r\nconst optionOfPreviousTodoInDom: T.Effect<\r\n  unknown,\r\n  Console & Dom,\r\n  ReturnType<typeof makeElementNotFound> | Error,\r\n  O.Option<HTMLLIElement>\r\n> = T.pure(O.none);\r\n\r\n/**\r\n * ```hs\r\n *\r\n * createAndUpdateTodoNode :: HTMLUListElement -> Effect (Option HTMLLIElement) -> Effect HTMLLIElement\r\n *\r\n * ```\r\n *\r\n * Creates new dom nodes for todos that are not yet present in the dom\r\n * and updates dom nodes of other todos\r\n *\r\n */\r\nconst createAndUpdateTodoNode = (ul: HTMLUListElement) => (\r\n  domNodeOfPreviousTodoInList: O.Option<HTMLLIElement>\r\n) => (todo: Todo) =>\r\n  pipe(\r\n    // Create a dom node\r\n    createDomNodeForTodo,\r\n    // Update it with information from the todo\r\n    T.chain(updateDomNodeOfTodo(todo)),\r\n    // Get the dom node it should attach itself to if available\r\n    // With the new dom node and it's \"previous sibling\"\r\n    T.chainTap((li) =>\r\n      pipe(\r\n        domNodeOfPreviousTodoInList,\r\n        O.fold(\r\n          // Prepend the dom node to the start of the list if no previous sibling is available\r\n          constant(T.sync(() => ul.prepend(li))),\r\n          // Other wise attach it after it's sibling\r\n          (domNodeOfPreviousTodoInList) =>\r\n            T.sync(() => domNodeOfPreviousTodoInList.after(li))\r\n        )\r\n      )\r\n    )\r\n  );\r\n\r\n/**\r\n * ```hs\r\n *\r\n * updateDomWithTodos :: HTMLUListElement -> [Todo] -> Effect\r\n *\r\n * ```\r\n *\r\n * Creates new dom nodes for todos that are not yet present in the dom\r\n * and updates dom nodes of other todos\r\n *\r\n */\r\nconst updateDomWithTodos = (ul: HTMLUListElement) => (todos: Todos) =>\r\n  pipe(\r\n    todos,\r\n    // Reduce the list of todos into a single effect\r\n    A.reduce(optionOfPreviousTodoInDom, (acc, todo) =>\r\n      pipe(\r\n        // Chain over the previous effect\r\n        acc,\r\n        T.chain((optionOfSiblingTodoInDom) =>\r\n          pipe(\r\n            ul,\r\n            querySelector<HTMLLIElement>(`[data-todo-id=\"${todo.id}\"]`),\r\n            O.fold(\r\n              // Create a dom node for new todos\r\n              // The accumulated effect is passed so that\r\n              // new dom nodes can attach themselves after the previous one\r\n              constant(\r\n                createAndUpdateTodoNode(ul)(optionOfSiblingTodoInDom)(todo)\r\n              ),\r\n              // Or if a dom node was found, update it\r\n              updateDomNodeOfTodo(todo)\r\n            ),\r\n            T.map(O.some)\r\n          )\r\n        )\r\n      )\r\n    )\r\n  );\r\n\r\n/**\r\n * ```hs\r\n *\r\n * commitStoreUpdatesToDom :: Effect\r\n *\r\n * ```\r\n *\r\n * Subscribes to store changes and updates the dom.\r\n *\r\n */\r\nconst commitStoreUpdatesToDom = T.Do()\r\n  .bind(\"store\", todoStore)\r\n  .bindL(\"subscription\", ({ store }) => store.subscribe)\r\n  .bind(\"ul\", todosUl)\r\n  // With store subscription and root dom node do:\r\n  .doL(({ subscription, ul }) =>\r\n    pipe(\r\n      subscription,\r\n      S.map((state) =>\r\n        state.filterBy === \"all\"\r\n          ? state.todos\r\n          : pipe(\r\n              state.todos,\r\n              A.filter((todo) =>\r\n                state.filterBy === \"completed\"\r\n                  ? todo.completed\r\n                  : !todo.completed\r\n              )\r\n            )\r\n      ),\r\n      // Take 10 todo items at a time\r\n      S.map(takeTenTodos),\r\n      // Keep track of previous list to use for comparison\r\n      S.scan(tuple(emptyListOfTodos, emptyListOfTodos), ([prev], next) =>\r\n        tuple(next, prev)\r\n      ),\r\n      S.chain(([next, prev]) =>\r\n        S.encaseEffect(\r\n          pipe(\r\n            // Remove todos that were in the previous list but not in the next\r\n            removeTodosFromDom(getTodosDifference(prev, next)),\r\n            // Add todos to the dom that are in the new list but weren't in the previous\r\n            // or update nodes with new information\r\n            T.zip(updateDomWithTodos(ul)(next))\r\n          )\r\n        )\r\n      ),\r\n      S.drain\r\n    )\r\n  )\r\n  .return(constVoid);\r\n\r\nconst updateCounter = pipe(\r\n  todoStore,\r\n  T.chain((store) => store.subscribe),\r\n  S.encaseEffect,\r\n  S.chain(identity),\r\n  S.map((state) => state.todos),\r\n  S.map((todos) =>\r\n    pipe(\r\n      todos,\r\n      A.filter((todo) => !todo.completed)\r\n    )\r\n  ),\r\n  S.map((todos) => todos.length),\r\n  S.chain((itemsLeft) =>\r\n    S.encaseEffect(\r\n      pipe(\r\n        $(\".todo-count\"),\r\n        T.map(querySelector(\"strong\")),\r\n        T.chain(\r\n          T.fromOption(constant(makeElementNotFound(\".todo-count > strong\")))\r\n        ),\r\n        T.chain((el) =>\r\n          T.sync(() => {\r\n            el.innerHTML = \"\" + itemsLeft;\r\n          })\r\n        )\r\n      )\r\n    )\r\n  ),\r\n  S.drain\r\n);\r\n\r\nconst makeHandleFilter = (filterBy: \"all\" | \"active\" | \"completed\") =>\r\n  pipe(\r\n    $<HTMLAnchorElement>(`#btn-filter-${filterBy}`),\r\n    S.encaseEffect,\r\n    S.chain(subscribe(\"click\")),\r\n    S.chain(\r\n      constant(\r\n        S.encaseEffect(\r\n          pipe(\r\n            T.parSequenceT(\r\n              $<HTMLAnchorElement>(`#btn-filter-all`),\r\n              $<HTMLAnchorElement>(`#btn-filter-active`),\r\n              $<HTMLAnchorElement>(`#btn-filter-completed`)\r\n            ),\r\n            T.chain((links) =>\r\n              T.sync(() => {\r\n                links.forEach((link) => link.classList.remove(\"selected\"));\r\n              })\r\n            )\r\n          )\r\n        )\r\n      )\r\n    ),\r\n    S.chain(\r\n      constant(\r\n        S.encaseEffect(\r\n          pipe(\r\n            todoStore,\r\n            T.chain((store) => store.next((state) => ({ ...state, filterBy })))\r\n          )\r\n        )\r\n      )\r\n    ),\r\n    S.chain(\r\n      constant(\r\n        S.encaseEffect(\r\n          pipe(\r\n            $<HTMLAnchorElement>(`#btn-filter-${filterBy}`),\r\n            T.chain((link) =>\r\n              T.sync(() => {\r\n                link.classList.add(\"selected\");\r\n              })\r\n            )\r\n          )\r\n        )\r\n      )\r\n    ),\r\n    S.drain\r\n  );\r\n\r\nconst handleClearCompleted = pipe(\r\n  $<HTMLButtonElement>(`.clear-completed`),\r\n  S.encaseEffect,\r\n  S.chain(subscribe(\"click\")),\r\n  S.chain(\r\n    constant(\r\n      S.encaseEffect(\r\n        pipe(\r\n          todoStore,\r\n          T.chain((store) =>\r\n            store.next((state) => ({\r\n              ...state,\r\n              todos: pipe(\r\n                state.todos,\r\n                A.filter((todo) => !todo.completed)\r\n              ),\r\n            }))\r\n          )\r\n        )\r\n      )\r\n    )\r\n  ),\r\n  S.drain\r\n);\r\n\r\nconst handleNewTodos = pipe(\r\n  $<HTMLInputElement>(\".new-todo\"),\r\n  S.encaseEffect,\r\n  S.chain(subscribe(\"keyup\")),\r\n  S.filter((event) => event.key === \"Enter\"),\r\n  S.map((event) => event.currentTarget as HTMLInputElement | null),\r\n  S.map(O.fromNullable),\r\n  S.chain(S.fromOption),\r\n  S.filter((input) => !!input.value.trim()),\r\n  S.chain((input) =>\r\n    S.encaseEffect(\r\n      pipe(\r\n        todoStore,\r\n        T.chain((store) =>\r\n          store.next((state) => ({\r\n            ...state,\r\n            todos: [\r\n              {\r\n                id: Math.random(),\r\n                title: input.value,\r\n                completed: false,\r\n                userId: Math.random(),\r\n              },\r\n              ...state.todos,\r\n            ],\r\n          }))\r\n        ),\r\n        T.chain(\r\n          constant(\r\n            T.sync(() => {\r\n              input.value = \"\";\r\n            })\r\n          )\r\n        )\r\n      )\r\n    )\r\n  ),\r\n  S.drain\r\n);\r\n\r\nconst allTodosAreCompleted = (todos: Todos): boolean =>\r\n  pipe(\r\n    todos,\r\n    A.foldLeft(\r\n      constTrue,\r\n      (todo, rest) => todo.completed && allTodosAreCompleted(rest)\r\n    )\r\n  );\r\n\r\nconst handleMarkAllAsCompleted = pipe(\r\n  $<HTMLInputElement>(\"#toggle-all\"),\r\n  T.zip(todoStore),\r\n  T.chain(([input, store]) =>\r\n    pipe(\r\n      store.subscribe,\r\n      T.map((susbscription) => tuple(input, store, susbscription))\r\n    )\r\n  ),\r\n  S.encaseEffect,\r\n  S.chain(([input, store, susbscription]) => {\r\n    const stateS: S.AsyncR<Emitter, void> = pipe(\r\n      susbscription,\r\n      S.map((state) => getFilteredTodos(state.filterBy)(state.todos)),\r\n      // Take 10 todo items at a time\r\n      S.map(takeTenTodos),\r\n      S.map((todos) => tuple(allTodosAreCompleted(todos), todos)),\r\n      S.chain(([allCompleted, todos]) =>\r\n        S.encaseEffect(\r\n          T.sync(() => {\r\n            input.checked = allCompleted;\r\n          })\r\n        )\r\n      ),\r\n      S.map(constVoid)\r\n    );\r\n\r\n    const clickS = pipe(\r\n      subscribe(\"click\")(input),\r\n      S.chain(\r\n        constant(\r\n          S.encaseEffect(\r\n            pipe(\r\n              store.get,\r\n              T.chain((stateO) =>\r\n                pipe(\r\n                  stateO,\r\n                  O.map((state) => {\r\n                    const todosListed = pipe(\r\n                      getFilteredTodos(state.filterBy)(state.todos),\r\n                      takeTenTodos\r\n                    );\r\n\r\n                    const completed = !allTodosAreCompleted(todosListed);\r\n\r\n                    return store.next((state) => ({\r\n                      ...state,\r\n                      todos: state.todos.map((todo) =>\r\n                        pipe(\r\n                          todosListed,\r\n                          A.findFirstMap((listedTodo) =>\r\n                            listedTodo.id !== todo.id\r\n                              ? O.none\r\n                              : O.some({ ...todo, completed })\r\n                          ),\r\n                          O.fold(constant(todo), identity)\r\n                        )\r\n                      ),\r\n                    }));\r\n                  }),\r\n                  O.getOrElse<T.Async<void>>(constant(T.sync(constVoid)))\r\n                )\r\n              )\r\n            )\r\n          )\r\n        )\r\n      ),\r\n      S.map(constVoid)\r\n    );\r\n\r\n    return S.mergeAll([stateS, clickS]);\r\n  }),\r\n  S.drain\r\n);\r\n/**\r\n * ```hs\r\n *\r\n * main :: Effect\r\n *\r\n * ```\r\n *\r\n * TodoMVC Program\r\n */\r\nexport const main = pipe(\r\n  T.parSequenceT(\r\n    logChanges,\r\n    fetchAndStoreTodos,\r\n    handleEvents,\r\n    commitStoreUpdatesToDom,\r\n    updateCounter,\r\n    makeHandleFilter(\"all\"),\r\n    makeHandleFilter(\"active\"),\r\n    makeHandleFilter(\"completed\"),\r\n    handleNewTodos,\r\n    handleClearCompleted,\r\n    handleMarkAllAsCompleted\r\n  ),\r\n  provideTodoStore\r\n);\r\n","import * as serviceWorker from \"./serviceWorker\";\nimport \"./index.scss\";\n\nimport { effect as T } from \"@matechs/effect\";\nimport { provideConsole } from \"@matechs/console\";\n\nimport { pipe } from \"fp-ts/lib/pipeable\";\n\nimport * as Todo from \"./modules/todo\";\nimport { provideDom } from \"./modules/dom\";\nimport { provideDocument } from \"./modules/document\";\nimport * as Fetch from \"./modules/fetch\";\n\nimport { makeEmitterLive } from \"./modules/emitter\";\n\n\nconst provided = pipe(\n    // Run the main todo program\n  Todo.main,\n  // Provide DOM utilities\n  provideDom,\n  // Provide document object\n  provideDocument,\n  // Provide window.fetch\n  Fetch.provideFetch,\n  // Provide logging capabilities\n  provideConsole,\n  // Provide event emitter with root element\n  T.provide(makeEmitterLive(document)),\n  // Provide depracated thing\n  // T.provide({\n  //   [T.AsyncRTURI]: {},\n  // }),\n);\n\nT.runToPromise(provided)\n  .then((foo) => console.log(\"Done\", foo))\n  .catch((error) => {\n    console.error(error);\n  });\n  \n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}